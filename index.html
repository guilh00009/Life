<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Thronglets - Egg Hatching</title>
    <style>
        body {
            background: linear-gradient(to bottom, #ff9966, #ff5e62);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
        }
        
        #game-container {
            text-align: center;
            position: relative;
        }
        
        #game-scene {
            width: 800px;
            height: 600px;
            background-color: #8CC152; /* Grass color */
            border-radius: 10px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.3);
            position: relative;
            overflow: hidden;
        }
        
        .tree {
            width: 40px;
            height: 40px;
            background-image: url('Tree.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            position: absolute;
        }
        
        #egg {
            width: 50px;
            height: 60px;
            background-image: url('eggbandolete.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            cursor: pointer;
            transition: transform 0.2s ease;
            z-index: 5;
        }
        
        #egg.shake {
            animation: shake 0.5s;
        }
        
        #egg.crack1 {
            background-image: url('eggbandolete.png');
            filter: brightness(0.95) contrast(1.05);
        }
        
        #egg.crack2 {
            background-image: url('eggbandolete.png');
            filter: brightness(0.9) contrast(1.1);
        }
        
        #thronglet {
            width: 40px;
            height: 40px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            display: none;
            z-index: 5;
            transition: transform 0.3s ease;
        }
        
        #thronglet.idle {
            background-image: url('Bandoletesidle.png');
        }
        
        #thronglet.walking {
            background-image: url('Bandoleteswalking.png');
        }
        
        #thronglet.sad {
            background-image: url('Bandoletesad.png');
        }
        
        .apple {
            width: 20px;
            height: 20px;
            background-color: red;
            border-radius: 50%;
            position: absolute;
            z-index: 4;
            box-shadow: 0 0 5px rgba(0,0,0,0.3);
        }
        
        .apple::before {
            content: '';
            position: absolute;
            top: -5px;
            left: 8px;
            width: 4px;
            height: 10px;
            background-color: brown;
            border-radius: 2px;
        }
        
        .ball {
            width: 25px;
            height: 25px;
            background: radial-gradient(circle at 30% 30%, #ff5252, #7e1313);
            border-radius: 50%;
            position: absolute;
            z-index: 4;
            box-shadow: 0 0 5px rgba(0,0,0,0.3);
        }
        
        #message {
            font-size: 24px;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            margin-top: 20px;
        }
        
        #status {
            font-size: 16px;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            margin-top: 10px;
            display: none;
        }
        
        #hunger-bar, #happiness-bar {
            width: 200px;
            height: 15px;
            margin: 5px auto;
            background-color: #e74c3c;
            border-radius: 5px;
            overflow: hidden;
        }
        
        #hunger-level, #happiness-level {
            height: 100%;
            width: 100%;
            background-color: #2ecc71;
            transition: width 0.5s ease;
        }
        
        #command-center {
            margin-top: 10px;
            display: none;
        }
        
        #command-input {
            width: 400px;
            padding: 8px;
            border-radius: 5px;
            border: none;
            margin-right: 5px;
        }
        
        #send-command {
            padding: 8px 15px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        
        #item-buttons {
            margin-top: 10px;
            display: none;
        }
        
        .item-button {
            padding: 8px 15px;
            margin: 0 5px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        
        #thought-bubble {
            position: absolute;
            background-color: white;
            border-radius: 10px;
            padding: 10px;
            max-width: 280px;
            font-size: 12px;
            box-shadow: 0 0 5px rgba(0,0,0,0.3);
            display: none;
            z-index: 20;
            line-height: 1.4;
            overflow-wrap: break-word;
            word-break: break-word;
            max-height: 300px;
            overflow-y: auto;
        }
        
        #thought-bubble:after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 20px;
            border-width: 10px 10px 0;
            border-style: solid;
            border-color: white transparent;
        }
        
        @keyframes shake {
            0% { transform: translate(-50%, -50%) rotate(0deg); }
            25% { transform: translate(-50%, -50%) rotate(2deg); }
            50% { transform: translate(-50%, -50%) rotate(0deg); }
            75% { transform: translate(-50%, -50%) rotate(-2deg); }
            100% { transform: translate(-50%, -50%) rotate(0deg); }
        }
        
        .thronglet-jump {
            animation: jump 0.5s ease;
        }
        
        @keyframes jump {
            0% { transform: translate(-50%, -50%) scale(1, 1); }
            30% { transform: translate(-50%, -60%) scale(0.9, 1.1); }
            50% { transform: translate(-50%, -70%) scale(1.1, 0.9); }
            70% { transform: translate(-50%, -60%) scale(0.95, 1.05); }
            100% { transform: translate(-50%, -50%) scale(1, 1); }
        }
        
        .thronglet-beep {
            background-image: url('bandoletebeep.png') !important;
            animation: beep 0.6s ease;
        }
        
        @keyframes beep {
            0% { transform: translate(-50%, -50%) scale(1, 1); }
            25% { transform: translate(-50%, -50%) scale(1.1, 0.9); }
            50% { transform: translate(-50%, -50%) scale(1.2, 0.8); }
            75% { transform: translate(-50%, -50%) scale(1.1, 0.9); }
            100% { transform: translate(-50%, -50%) scale(1, 1); }
        }
        
        .thronglet-stats {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 5px;
            padding: 5px;
            width: 120px;
            display: none;
            z-index: 15;
        }
        
        .thronglet-hunger-bar, .thronglet-happiness-bar {
            width: 100%;
            height: 10px;
            margin: 3px 0;
            background-color: #e74c3c;
            border-radius: 3px;
            overflow: hidden;
        }
        
        .thronglet-hunger-level, .thronglet-happiness-level {
            height: 100%;
            width: 100%;
            background-color: #2ecc71;
            transition: width 0.5s ease;
        }
        
        .stat-label {
            color: white;
            font-size: 10px;
            margin: 2px 0;
            text-align: left;
        }

        #mobile-warning {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            text-align: center;
            padding: 20px;
        }
        
        #mobile-warning h2 {
            color: #ff5e62;
            font-size: 24px;
            margin-bottom: 15px;
        }
        
        #mobile-warning p {
            font-size: 16px;
            margin-bottom: 20px;
            max-width: 600px;
        }
        
        #mobile-warning button {
            background-color: #ff5e62;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
        }

        .apple-tree {
            width: 50px;
            height: 55px;
            background-image: url('Tree.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            position: absolute;
            z-index: 4;
        }
        
        .apple-tree:after {
            content: '';
            position: absolute;
            width: 45px;
            height: 45px;
            top: -10px;
            left: 3px;
            background: radial-gradient(circle at center, rgba(255,0,0,0.6) 0%, rgba(255,0,0,0) 70%);
            border-radius: 50%;
            z-index: -1;
        }
        
        .apple-tree .tree-apple {
            width: 12px;
            height: 12px;
            background-color: red;
            border-radius: 50%;
            position: absolute;
            box-shadow: 0 0 3px rgba(0,0,0,0.3);
            animation: sway 3s infinite ease-in-out;
        }
        
        .apple-tree .tree-apple::before {
            content: '';
            position: absolute;
            top: -3px;
            left: 5px;
            width: 2px;
            height: 6px;
            background-color: brown;
            border-radius: 1px;
        }
        
        @keyframes sway {
            0% { transform: rotate(0deg); }
            25% { transform: rotate(3deg); }
            50% { transform: rotate(0deg); }
            75% { transform: rotate(-3deg); }
            100% { transform: rotate(0deg); }
        }
        
        .falling-apple {
            width: 12px;
            height: 12px;
            background-color: red;
            border-radius: 50%;
            position: absolute;
            box-shadow: 0 0 3px rgba(0,0,0,0.3);
            z-index: 3;
            animation: fall 1s forwards;
        }
        
        .falling-apple::before {
            content: '';
            position: absolute;
            top: -3px;
            left: 5px;
            width: 2px;
            height: 6px;
            background-color: brown;
            border-radius: 1px;
        }
        
        @keyframes fall {
            0% { transform: translateY(0); }
            100% { transform: translateY(40px); }
        }

        .thronglet-intelligence-level, .thronglet-teamwork-level, .thronglet-communication-level {
            animation: shine 2s linear infinite;
            background-image: linear-gradient(
                -45deg, 
                rgba(255, 255, 255, 0.2) 25%, 
                transparent 25%, 
                transparent 50%, 
                rgba(255, 255, 255, 0.2) 50%, 
                rgba(255, 255, 255, 0.2) 75%, 
                transparent 75%, 
                transparent
            );
            background-size: 20px 20px;
        }
        
        @keyframes shine {
            0% { background-position: 0 0; }
            100% { background-position: 20px 0; }
        }

        @keyframes sparkle {
            0% { transform: scale(0.5); opacity: 1; }
            100% { transform: scale(2); opacity: 0; }
        }

        /* Add CSS styles for the brain visualizer */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            overflow: auto;
        }
        
        .modal-content {
            background: linear-gradient(to bottom, #2c3e50, #1a2530);
            margin: 5% auto;
            padding: 20px;
            width: 80%;
            max-width: 800px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            color: white;
        }
        
        .close-button {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        
        .close-button:hover {
            color: white;
        }
        
        .visualizer-controls {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            padding: 10px;
            background-color: rgba(0,0,0,0.2);
            border-radius: 5px;
        }
        
        .visualizer-container {
            position: relative;
            width: 100%;
            height: 420px;
            background-color: #1a1a2e;
            border-radius: 8px;
            padding: 10px;
            box-sizing: border-box;
            margin-top: 15px;
            overflow: hidden;
            border: 1px solid #30336b;
        }
        
        #brain-canvas {
            position: relative;
            width: 700px;
            height: 400px;
            background-color: #0a0a0a;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0,255,255,0.3);
            display: block;
            margin: 0 auto;
            z-index: 10;
        }
        
        #neuron-info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            right: 10px;
            background-color: rgba(30, 30, 60, 0.8);
            color: #ffffff;
            padding: 10px;
            border-radius: 5px;
            min-height: 30px;
            font-family: monospace;
            z-index: 20;
        }
        
        #thronglet-selector {
            padding: 8px;
            border-radius: 5px;
            background-color: #34495e;
            color: white;
            border: 1px solid #3498db;
        }
        
        .speed-control {
            display: flex;
            align-items: center;
        }
        
        .speed-control label {
            margin-right: 10px;
        }
        
        #update-speed {
            width: 150px;
        }
        
        .learning-sparkle {
            position: absolute;
            z-index: 100;
            font-size: 16px;
            font-weight: bold;
            text-align: center;
            font-family: Arial, sans-serif;
            padding: 5px 10px;
            border-radius: 12px;
            background-color: rgba(255, 255, 255, 0.8);
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
            pointer-events: none;
            animation: sparkleEffect 2s ease-out forwards;
            transform: translateX(-50%);
        }
        
        @keyframes sparkleEffect {
            0% {
                transform: translateX(-50%) translateY(0) scale(0.5);
                opacity: 0;
            }
            20% {
                transform: translateX(-50%) translateY(-10px) scale(1.2);
                opacity: 1;
            }
            80% {
                transform: translateX(-50%) translateY(-25px) scale(1);
                opacity: 0.8;
            }
            100% {
                transform: translateX(-50%) translateY(-40px) scale(0.8);
                opacity: 0;
            }
        }

        /* Add style for modal to make sure it's visible */
        #brain-visualizer-modal {
            display: none; /* Hidden by default */
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 1000; /* Very high z-index to be on top */
            overflow: auto;
        }

        .modal-content {
            position: relative;
            background-color: #0f0f1a;
            margin: 2% auto;
            padding: 20px;
            width: 85%;
            max-width: 900px;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
            border-radius: 10px;
            border: 1px solid #30336b;
            z-index: 1001;
        }
        
        /* Add styles for learning path */
        .learning-path {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            z-index: 3;
            pointer-events: none;
            animation: fadeOut 1.5s forwards;
        }
        
        @keyframes fadeOut {
            0% { opacity: 0.6; }
            100% { opacity: 0; }
        }
    </style>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>🐣</text></svg>" />
</head>
<body>
    <div id="mobile-warning">
        <h2>⚠️ Mobile Not Supported ⚠️</h2>
        <p>Thronglets requires a desktop computer to work properly. The game uses mouse interactions and desktop-specific features that don't translate well to mobile devices.</p>
        <p>For the best experience, please visit this site on a desktop computer with a mouse.</p>
        <button id="continue-anyway">Continue Anyway</button>
    </div>
    <div id="game-container">
        <div id="game-scene">
            <div id="egg"></div>
            <div id="thronglet" style="display: none;"></div>
            <div id="thought-bubble">Hello!</div>
        </div>
        <div id="message">Click the egg 3 times to hatch a Thronglet!</div>
        <div id="status">
            <div>Hunger: <div id="hunger-bar"><div id="hunger-level"></div></div></div>
            <div>Happiness: <div id="happiness-bar"><div id="happiness-level"></div></div></div>
        </div>
        <div id="command-center">
            <!-- Creator meeting button removed -->
        </div>
        <div id="item-buttons">
            <button class="item-button" id="place-apple">Place Apple</button>
            <button class="item-button" id="place-ball">Place Ball</button>
            <button class="item-button" id="toggle-communication">Communicate</button>
        </div>
        
        <!-- Communication Interface -->
        <div id="communication-interface" style="margin-top: 10px; display: none;">
            <div style="display: flex; margin-bottom: 10px;">
                <input type="text" id="message-input" placeholder="Type your message..." style="flex: 1; padding: 8px; border-radius: 5px; border: none;">
                <select id="message-target" style="margin-left: 10px; padding: 8px; border-radius: 5px; border: none;">
                    <option value="all">All Thronglets</option>
                    <!-- Individual Thronglet options will be added dynamically -->
                </select>
                <button id="send-message" style="margin-left: 10px; padding: 8px 15px; background-color: #3498db; color: white; border: none; border-radius: 5px; cursor: pointer;">Send</button>
            </div>
            <div style="display: flex; align-items: center;">
                <label style="margin-right: 10px; font-size: 14px; color: white;">Use Morse Code:</label>
                <input type="checkbox" id="use-morse" checked>
                <div id="morse-preview" style="margin-left: 15px; color: white; font-size: 14px; font-family: monospace;"></div>
            </div>
        </div>
    </div>
    
    <!-- Brain Visualizer Modal -->
    <div id="brain-visualizer-modal" class="modal">
        <div class="modal-content">
            <span class="close-button">&times;</span>
            <h2>Thronglet Brain Visualizer</h2>
            <div id="layers-counter" style="color: #3498db; font-size: 14px; margin-bottom: 10px;">Hidden Layers: 3</div>
            <div class="visualizer-controls">
                <select id="thronglet-selector">
                    <option value="">Select a Thronglet</option>
                </select>
                <div class="speed-control">
                    <label for="update-speed">Update Speed:</label>
                    <input type="range" id="update-speed" min="100" max="2000" value="500" step="100">
                </div>
            </div>
            <div class="visualizer-container">
                <canvas id="brain-canvas" width="700" height="400"></canvas>
                <div id="neuron-info">Select a neuron to see its details</div>
            </div>
        </div>
    </div>

    <script>
        const gameScene = document.getElementById('game-scene');
        const egg = document.getElementById('egg');
        const thronglet = document.getElementById('thronglet');
        const message = document.getElementById('message');
        const statusDiv = document.getElementById('status');
        const hungerLevel = document.getElementById('hunger-level');
        const happinessLevel = document.getElementById('happiness-level');
        const commandCenter = document.getElementById('command-center');
        const itemButtons = document.getElementById('item-buttons');
        const placeApple = document.getElementById('place-apple');
        const placeBall = document.getElementById('place-ball');
        const thoughtBubble = document.getElementById('thought-bubble');
        
        const sceneWidth = 800;
        const sceneHeight = 600;
        let clicks = 0;
        let isPlacingApple = false;
        let isPlacingBall = false;
        let apples = [];
        let balls = [];
        let thoughtTimer = null;
        let walkAnimationFrame = 0;
        let walkAnimationTimer = null;
        let gameActive = false;
        let thronglets = [];
        let nextThrongletId = 0;
        let wellBeingTimer = null;
        
        // Add ball physics variables
        let activeBall = null;
        let ballVelocityX = 0;
        let ballVelocityY = 0;
        let isBallMoving = false;
        
        // Add LLM integration variables
        let apiKey = "fw_3ZLZxEU9XkYj9MdDRyzYfCxn"; // Pre-set API key
        let isLlmEnabled = true; // Enable by default
        let llmRequestQueue = [];
        let isProcessingLlmRequest = false;
        let suggestedFeatures = [];
        let featureVotes = {};
        let conversationHistory = [];
        let isCreatorMeeting = false;
        let nextCreatorMeetingTime = null;
        let creatorMeetingInterval = null;
        
        // Add these variables for Thronglet conversations:
        let isThrongletChatting = false;
        let lastChatTime = 0;
        let chatCooldown = 20000; // 20 seconds minimum between spontaneous chats
        let ongoingConversations = {};
        
        // Hidden layers doubling variables
        let hiddenLayersCount = 3; // Start with 3 hidden layers
        let lastHiddenLayersUpdate = null; // Track when we last updated layers
        
        // Audio context for beep sounds
        let audioContext = null;
        try {
            // Create audio context on user interaction to avoid autoplay restrictions
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
        } catch (e) {
            console.warn("Web Audio API not supported in this browser");
        }
        
        // Learning agent variables
        let agentLearningEnabled = true;
        let observationPhase = true; // Start in observation mode
        let observationTime = 60000; // Observe for 60 seconds before starting to learn
        let observationStartTime = null;
        let learningRate = 0.01; // How quickly agents adjust their weights
        let discountFactor = 0.95; // How much future rewards matter
        let explorationRate = 0.3; // How often to try random actions (will decrease over time)
        
        // State and action recording
        let stateActionHistory = [];
        let globalStateHistory = [];
        
        // Teamwork tracking
        let teamworkEvents = [];
        let teamworkRewards = {}; // Tracking rewards earned through teamwork
        
        // Beep communication learning
        let beepPatterns = [
            { id: 0, meaning: "hungry", pattern: [300, 0.2], rewards: 0, uses: 0 },
            { id: 1, meaning: "play", pattern: [350, 0.2], rewards: 0, uses: 0 },
            { id: 2, meaning: "help", pattern: [400, 0.2], rewards: 0, uses: 0 },
            { id: 3, meaning: "follow", pattern: [320, 0.2], rewards: 0, uses: 0 },
            { id: 4, meaning: "danger", pattern: [380, 0.2], rewards: 0, uses: 0 }
        ];
        
        // Add global context system:

        // Global context tracking system - collects information about everything in the game
        let globalContext = {
            gameStartTime: Date.now(),
            sessionEvents: [],      // Tracks all events in this session
            throngletMemory: {},    // Individual memory for each Thronglet
            appleHistory: [],       // History of all apple placements and consumption
            ballHistory: [],        // History of all ball placements and interactions
            creatorInteractions: [] // All interactions with the Creator
        };

        // Maximum memory items per Thronglet for performance
        const MAX_MEMORY_ITEMS = 25;
        
        // Function to add events to global context
        function trackEvent(eventType, details) {
            const event = {
                timestamp: Date.now(),
                type: eventType,
                details: details
            };
            
            // Add to session events
            globalContext.sessionEvents.push(event);
            
            // Also track in specific history lists
            if (eventType === 'apple_placed' || eventType === 'apple_eaten') {
                globalContext.appleHistory.push(event);
            } else if (eventType === 'ball_placed' || eventType === 'ball_kicked') {
                globalContext.ballHistory.push(event);
            } else if (eventType === 'creator_message' || eventType === 'creator_meeting') {
                globalContext.creatorInteractions.push(event);
            }
            
            // Keep lists trimmed for performance
            if (globalContext.sessionEvents.length > 100) {
                globalContext.sessionEvents = globalContext.sessionEvents.slice(-100);
            }
            if (globalContext.appleHistory.length > 50) {
                globalContext.appleHistory = globalContext.appleHistory.slice(-50);
            }
            if (globalContext.ballHistory.length > 50) {
                globalContext.ballHistory = globalContext.ballHistory.slice(-50);
            }
            if (globalContext.creatorInteractions.length > 50) {
                globalContext.creatorInteractions = globalContext.creatorInteractions.slice(-50);
            }
            
            // Save context to localStorage for persistence
            saveContextToStorage();
        }
        
        // Function to add memory item to specific Thronglet
        function addThrongletMemory(throngletId, memoryType, content) {
            if (!globalContext.throngletMemory[throngletId]) {
                globalContext.throngletMemory[throngletId] = [];
            }
            
            globalContext.throngletMemory[throngletId].push({
                timestamp: Date.now(),
                type: memoryType,
                content: content
            });
            
            // Trim memory if it gets too large
            if (globalContext.throngletMemory[throngletId].length > MAX_MEMORY_ITEMS) {
                globalContext.throngletMemory[throngletId] = globalContext.throngletMemory[throngletId].slice(-MAX_MEMORY_ITEMS);
            }
            
            saveContextToStorage();
        }
        
        // Save context to localStorage
        function saveContextToStorage() {
            try {
                localStorage.setItem('throngletContext', JSON.stringify(globalContext));
            } catch (e) {
                console.warn("Failed to save context to localStorage:", e);
            }
        }
        
        // Load context from localStorage
        function loadContextFromStorage() {
            try {
                const savedContext = localStorage.getItem('throngletContext');
                if (savedContext) {
                    globalContext = JSON.parse(savedContext);
                    console.log("Loaded saved context");
                }
            } catch (e) {
                console.warn("Failed to load context from localStorage:", e);
            }
        }
        
        // Try to load context on startup
        loadContextFromStorage();
        
        // Create Thronglet class to manage multiple Thronglets
        class Thronglet {
            constructor(x, y, parentId = null) {
                this.id = nextThrongletId++;
                this.x = x;
                this.y = y;
                this.targetX = null;
                this.targetY = null;
                this.hunger = 100;
                this.happiness = 100;
                this.isMoving = false;
                this.wellBeingTime = 0; // Time spent with high hunger and happiness
                this.element = null;
                this.walkFrame = 0;
                this.canMultiply = true; // Prevents continuous multiplication
                this.multiplyTimeout = null;
                this.birthTime = Date.now(); // Track when this Thronglet was born
                this.lastMultiplyTime = this.birthTime; // Track when this Thronglet last multiplied
                this.parentId = parentId; // Track parent for family relationships
                this.personality = this.generatePersonality(); // Generate a unique personality
                
                // Initialize memory in global context
                if (!globalContext.throngletMemory[this.id]) {
                    globalContext.throngletMemory[this.id] = [];
                }
                
                // Track Thronglet creation in global context
                trackEvent('thronglet_created', {
                    id: this.id,
                    birthTime: this.birthTime,
                    parentId: this.parentId,
                    personality: this.personality
                });
                
                // Add initial memory
                if (parentId === null) {
                    addThrongletMemory(this.id, 'birth', 'I hatched from an egg brought by the Creator.');
                } else {
                    addThrongletMemory(this.id, 'birth', `I was created when Thronglet #${parentId} multiplied.`);
                }
                
                this.createThrongletElement();
                
                // Create an agent for this Thronglet if learning is enabled
                if (agentLearningEnabled) {
                    this.agent = new PerceptronAgent(this);
                } else {
                    this.agent = null;
                }
            }
            
            createThrongletElement() {
                this.element = document.createElement('div');
                this.element.className = 'thronglet idle';
                this.element.style.left = this.x + 'px';
                this.element.style.top = this.y + 'px';
                this.element.style.display = 'block';
                this.element.style.width = '40px';
                this.element.style.height = '40px';
                this.element.style.backgroundImage = 'url("Bandoletesidle.png")';
                this.element.style.backgroundSize = 'contain';
                this.element.style.backgroundRepeat = 'no-repeat';
                this.element.style.backgroundPosition = 'center';
                this.element.style.position = 'absolute';
                this.element.style.transform = 'translate(-50%, -50%)';
                this.element.style.zIndex = '5';
                this.element.style.transition = 'transform 0.3s ease';
                this.element.style.cursor = 'pointer';
                console.log("Created Thronglet at", this.x, this.y);
                
                // Create stats display
                this.statsElement = document.createElement('div');
                this.statsElement.className = 'thronglet-stats';
                
                // Add hunger display
                const hungerLabel = document.createElement('div');
                hungerLabel.className = 'stat-label';
                hungerLabel.textContent = 'Hunger:';
                this.statsElement.appendChild(hungerLabel);
                
                const hungerBar = document.createElement('div');
                hungerBar.className = 'thronglet-hunger-bar';
                this.hungerLevel = document.createElement('div');
                this.hungerLevel.className = 'thronglet-hunger-level';
                hungerBar.appendChild(this.hungerLevel);
                this.statsElement.appendChild(hungerBar);
                
                // Add happiness display
                const happinessLabel = document.createElement('div');
                happinessLabel.className = 'stat-label';
                happinessLabel.textContent = 'Happiness:';
                this.statsElement.appendChild(happinessLabel);
                
                const happinessBar = document.createElement('div');
                happinessBar.className = 'thronglet-happiness-bar';
                this.happinessLevel = document.createElement('div');
                this.happinessLevel.className = 'thronglet-happiness-level';
                happinessBar.appendChild(this.happinessLevel);
                this.statsElement.appendChild(happinessBar);
                
                // Add ID display
                const idLabel = document.createElement('div');
                idLabel.className = 'stat-label';
                idLabel.textContent = `Thronglet #${this.id}`;
                this.statsElement.appendChild(idLabel);
                
                // Position the stats above the Thronglet
                this.updateStatsPosition();
                
                // Add click event to show/hide stats
                this.element.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent placing apples/balls when clicking on Thronglet
                    this.toggleStats();
                });
                
                // Add elements to the game scene
                gameScene.appendChild(this.element);
                gameScene.appendChild(this.statsElement);
            }
            
            setClassName(className) {
                this.element.className = 'thronglet ' + className;
                
                // Update background image based on state
                if (className === 'idle') {
                    this.element.style.backgroundImage = 'url("Bandoletesidle.png")';
                } else if (className === 'walking') {
                    this.element.style.backgroundImage = 'url("Bandoleteswalking.png")';
                } else if (className === 'sad') {
                    this.element.style.backgroundImage = 'url("Bandoletesad.png")';
                }
            }
            
            updatePosition() {
                if (!this.isMoving || this.targetX === null || this.targetY === null) return;
                
                const speed = 0.8;
                const dx = this.targetX - this.x;
                const dy = this.targetY - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 5) {
                    // Reached the target
                    this.isMoving = false;
                    this.setClassName('idle');
                    
                    // Check if reached an apple
                    this.checkForApple();
                    
                    // Check if reached a ball
                    this.checkForBall();
                    
                    return;
                }
                
                // Move towards target
                this.x += (dx / distance) * speed;
                this.y += (dy / distance) * speed;
                
                // Update position
                this.element.style.left = this.x + 'px';
                this.element.style.top = this.y + 'px';
                
                // Update stats position if visible
                this.updateStatsPosition();
                
                // Update thought bubble position if this Thronglet is currently speaking
                if (thoughtBubble.style.display === 'block' && this.isCurrentlySpeaking) {
                    this.updateThoughtBubblePosition();
                }
            }
            
            moveTowards(x, y) {
                this.targetX = x;
                this.targetY = y;
                this.isMoving = true;
                this.setClassName('walking');
            }
            
            animateWalking() {
                if (!this.isMoving) {
                    this.setClassName('idle');
                    return;
                }
                
                this.walkFrame++;
                if (this.walkFrame % 2 === 0) {
                    this.setClassName('walking');
                } else {
                    this.setClassName('idle');
                }
            }
            
            checkForApple() {
                for (let i = 0; i < apples.length; i++) {
                    const apple = apples[i];
                    
                    // Check if another Thronglet is already going for this apple
                    let isTargeted = false;
                    for (const otherThronglet of thronglets) {
                        if (otherThronglet !== this && otherThronglet.isMoving && 
                            otherThronglet.targetX === apple.x && otherThronglet.targetY === apple.y) {
                            isTargeted = true;
                            break;
                        }
                    }
                    
                    if (isTargeted) continue;
                    
                    const distance = Math.sqrt(
                        Math.pow(this.x - apple.x, 2) + 
                        Math.pow(this.y - apple.y, 2)
                    );
                    
                    // Simulate the learning process of approaching and eating food
                    if (distance < 30) {
                        // Check if this is one of the first few apples this Thronglet has encountered
                        const eatenMemories = (globalContext.throngletMemory[this.id] || [])
                            .filter(m => m.type === 'apple_eaten');
                        const isLearning = eatenMemories.length < 3;
                        
                        if (isLearning) {
                            // Learning phase - show learning behavior
                            this.jump();
                            this.showThought("I'm learning how to eat this apple!");
                            
                            // Add learning sparkle effect
                            showLearningSparkle(this.x, this.y, "Learning!");
                            
                            // First approach with uncertainty - wait a bit
                            setTimeout(() => {
                                // If the apple still exists and we haven't moved away
                                if (i < apples.length && apples[i] && !this.isMoving && 
                                    Math.sqrt(Math.pow(this.x - apple.x, 2) + Math.pow(this.y - apple.y, 2)) < 30) {
                                    
                                    this.showThought("Yum! I figured out how to eat the apple!");
                                    this.hunger = Math.min(100, this.hunger + 30);
                                    
                                    // Track apple eating in global context
                                    trackEvent('apple_eaten', {
                                        throngletId: this.id,
                                        appleIndex: i,
                                        position: { x: apple.x, y: apple.y },
                                        newHunger: this.hunger,
                                        learningPhase: true
                                    });
                                    
                                    // Add to Thronglet's personal memory
                                    addThrongletMemory(this.id, 'apple_eaten', `I learned how to eat an apple! My hunger increased to ${this.hunger}%.`);
                                    
                                    // Show another learning sparkle
                                    showLearningSparkle(this.x, this.y, "Eating +1");
                                    
                                    // Remove the apple - with safety check
                                    if (apple.element && apple.element.parentNode) {
                                        apple.element.parentNode.removeChild(apple.element);
                                    }
                                    apples.splice(i, 1);
                                }
                            }, 1000); // Delay to show learning process
                        } else {
                            // Already learned - eat immediately
                            this.jump();
                            this.showThought("Yum! Delicious apple!");
                            this.hunger = Math.min(100, this.hunger + 30);
                            
                            // Track apple eating in global context
                            trackEvent('apple_eaten', {
                                throngletId: this.id,
                                appleIndex: i,
                                position: { x: apple.x, y: apple.y },
                                newHunger: this.hunger
                            });
                            
                            // Add to Thronglet's personal memory
                            addThrongletMemory(this.id, 'apple_eaten', `I ate an apple and my hunger increased to ${this.hunger}%.`);
                            
                            // Remove the apple - with safety check
                            if (apple.element && apple.element.parentNode) {
                                apple.element.parentNode.removeChild(apple.element);
                            }
                            apples.splice(i, 1);
                        }
                        break;
                    }
                }
            }
            
            checkForBall() {
                if (isBallMoving) return; // Don't interact with ball while it's moving
                
                for (let i = 0; i < balls.length; i++) {
                    const ball = balls[i];
                    
                    // Check if another Thronglet is already going for this ball
                    let isTargeted = false;
                    for (const otherThronglet of thronglets) {
                        if (otherThronglet !== this && otherThronglet.isMoving && 
                            otherThronglet.targetX === ball.x && otherThronglet.targetY === ball.y) {
                            isTargeted = true;
                            break;
                        }
                    }
                    
                    if (isTargeted) continue;
                    
                    const distance = Math.sqrt(
                        Math.pow(this.x - ball.x, 2) + 
                        Math.pow(this.y - ball.y, 2)
                    );
                    
                    // Simulate the learning process of approaching and kicking the ball
                    if (distance < 30) {
                        // Check if this is one of the first few balls this Thronglet has encountered
                        const kickedMemories = (globalContext.throngletMemory[this.id] || [])
                            .filter(m => m.type === 'ball_kicked');
                        const isLearning = kickedMemories.length < 3;
                        
                        // Check if this ball was already kicked by a different thronglet (for teamwork reward)
                        const isTeamworkKick = ball.lastKickedBy !== null && 
                                               ball.lastKickedBy !== this.id && 
                                               ball.lastKickTime && 
                                               (Date.now() - ball.lastKickTime < 10000); // Within last 10 seconds
                        
                        // Calculate base happiness increase
                        let happinessIncrease = 20;
                        
                        // Double happiness for teamwork (kicking a ball another thronglet kicked)
                        if (isTeamworkKick) {
                            happinessIncrease *= 2;
                            
                            // Track teamwork rewards
                            if (!teamworkRewards[this.id]) {
                                teamworkRewards[this.id] = 0;
                            }
                            teamworkRewards[this.id]++;
                            
                            // Show special teamwork sparkle
                            showLearningSparkle(this.x, this.y, "Teamwork! +2x");
                        }
                        
                        if (isLearning) {
                            // Learning phase - show learning behavior
                            this.jump();
                            this.showThought("I'm learning how to kick this ball!");
                            
                            // Add learning sparkle effect
                            showLearningSparkle(this.x, this.y, "Learning!");
                            
                            // First approach with uncertainty - wait a bit
                            setTimeout(() => {
                                // If the ball still exists and we haven't moved away
                                if (i < balls.length && balls[i] && !this.isMoving && !isBallMoving &&
                                    Math.sqrt(Math.pow(this.x - ball.x, 2) + Math.pow(this.y - ball.y, 2)) < 30) {
                                    
                                    let thoughtText = "I figured out how to kick the ball!";
                                    if (isTeamworkKick) {
                                        thoughtText = `I kicked the ball that Thronglet #${ball.lastKickedBy} kicked! Double happiness!`;
                                    }
                                    
                                    this.showThought(thoughtText);
                                    this.happiness = Math.min(100, this.happiness + happinessIncrease);
                                    
                                    // Track ball kicking in global context
                                    trackEvent('ball_kicked', {
                                        throngletId: this.id,
                                        ballIndex: i,
                                        position: { x: ball.x, y: ball.y },
                                        newHappiness: this.happiness,
                                        learningPhase: true,
                                        isTeamworkKick: isTeamworkKick,
                                        previousKicker: ball.lastKickedBy
                                    });
                                    
                                    // Add to Thronglet's personal memory
                                    let memoryText = isTeamworkKick 
                                        ? `I learned to kick a ball that Thronglet #${ball.lastKickedBy} kicked! My happiness doubled to ${this.happiness}%!` 
                                        : `I learned how to kick a ball! My happiness increased to ${this.happiness}%.`;
                                    
                                    addThrongletMemory(this.id, 'ball_kicked', memoryText);
                                    
                                    // Show appropriate learning sparkle
                                    showLearningSparkle(this.x, this.y, isTeamworkKick ? "Teamwork +2x" : "Kicking +1");
                                    
                                    // Calculate kick direction (away from thronglet)
                                    const kickAngle = Math.atan2(ball.y - this.y, ball.x - this.x);
                                    const kickPower = 3 + Math.random() * 2; // Weaker kick while learning (3-5)
                                    
                                    // Set ball velocity
                                    ballVelocityX = Math.cos(kickAngle) * kickPower;
                                    ballVelocityY = Math.sin(kickAngle) * kickPower;
                                    
                                    // Start ball movement - with safety check
                                    if (ball && ball.element) {
                                        // Update ball's last kicked info
                                        ball.lastKickedBy = this.id;
                                        ball.lastKickTime = Date.now();
                                        
                                        activeBall = ball;
                                        isBallMoving = true;
                                        requestAnimationFrame(moveBall);
                                    }
                                }
                            }, 1000); // Delay to show learning process
                        } else {
                            // Already learned - kick immediately with more force
                            this.jump();
                            
                            let thoughtText = "I'm kicking the ball!";
                            if (isTeamworkKick) {
                                thoughtText = `I kicked the ball that Thronglet #${ball.lastKickedBy} kicked! Double happiness!`;
                            }
                            
                            this.showThought(thoughtText);
                            this.happiness = Math.min(100, this.happiness + happinessIncrease);
                            
                            // Track ball kicking in global context
                            trackEvent('ball_kicked', {
                                throngletId: this.id,
                                ballIndex: i,
                                position: { x: ball.x, y: ball.y },
                                newHappiness: this.happiness,
                                isTeamworkKick: isTeamworkKick,
                                previousKicker: ball.lastKickedBy
                            });
                            
                            // Add to Thronglet's personal memory
                            let memoryText = isTeamworkKick 
                                ? `I kicked a ball that Thronglet #${ball.lastKickedBy} kicked and got double happiness! Now at ${this.happiness}%.` 
                                : `I kicked a ball and my happiness increased to ${this.happiness}%.`;
                            
                            addThrongletMemory(this.id, 'ball_kicked', memoryText);
                            
                            // Calculate kick direction (away from thronglet)
                            const kickAngle = Math.atan2(ball.y - this.y, ball.x - this.x);
                            const kickPower = 5 + Math.random() * 3; // Stronger kick after learning (5-8)
                            
                            // Set ball velocity
                            ballVelocityX = Math.cos(kickAngle) * kickPower;
                            ballVelocityY = Math.sin(kickAngle) * kickPower;
                            
                            // Start ball movement - with safety check
                            if (ball && ball.element) {
                                // Update ball's last kicked info
                                ball.lastKickedBy = this.id;
                                ball.lastKickTime = Date.now();
                                
                                activeBall = ball;
                                isBallMoving = true;
                                requestAnimationFrame(moveBall);
                            }
                        }
                        
                        break;
                    }
                }
            }
            
            decreaseHunger() {
                this.hunger = Math.max(0, this.hunger - 5);
                if (this.hunger === 0) {
                    this.showThought("I'm starving! Please feed me!");
                    this.setClassName('sad');
                }
            }
            
            decreaseHappiness() {
                this.happiness = Math.max(0, this.happiness - 3);
                if (this.happiness < 30 && balls.length === 0) {
                    this.showThought("I'm so bored! I wish I had a ball to play with.");
                    this.setClassName('sad');
                }
            }
            
            updateWellBeing() {
                const currentTime = Date.now();
                // Check if 30 seconds have passed since birth or last multiplication
                if (currentTime - this.lastMultiplyTime >= 30000 && this.canMultiply && thronglets.length < 5) {
                    this.multiply();
                    this.lastMultiplyTime = currentTime; // Update last multiplication time
                }
            }
            
            multiply() {
                this.jump();
                this.showThought("Time to multiply!");
                
                // Find a nearby spot for the new Thronglet
                const angle = Math.random() * Math.PI * 2;
                const distance = 50;
                const newX = this.x + Math.cos(angle) * distance;
                const newY = this.y + Math.sin(angle) * distance;
                
                // Create new Thronglet with parent ID
                const newThronglet = new Thronglet(newX, newY, this.id);
                thronglets.push(newThronglet);
                
                // Track multiplication in global context
                trackEvent('thronglet_multiplied', {
                    parentId: this.id,
                    childId: newThronglet.id,
                    parentHunger: this.hunger,
                    parentHappiness: this.happiness
                });
                
                // Add to Thronglet's personal memory
                addThrongletMemory(this.id, 'multiplication', `I multiplied and created Thronglet #${newThronglet.id}.`);
                
                // Update the counter
                updateThrongletCounter();
            }
            
            showThought(text) {
                thoughtBubble.textContent = text;
                
                // Track speech in global context
                trackEvent('thronglet_speech', {
                    id: this.id,
                    text: text,
                    hunger: this.hunger,
                    happiness: this.happiness
                });
                
                // Add to Thronglet's personal memory
                addThrongletMemory(this.id, 'speech', text);
                
                // Play beep sound with Morse code capability
                playBeepSound(this, text);
                
                // Calculate bubble position to ensure it's visible
                // Adjust position based on screen boundaries
                const bubbleWidth = 280; // Match the max-width in CSS
                const bubbleHeight = Math.min(text.length / 2, 300); // Estimate height
                
                // Determine best position to keep bubble on screen
                let leftPos = this.x - (bubbleWidth / 2);
                let topPos = this.y - bubbleHeight - 30; // Position above Thronglet with some padding
                
                // Keep bubble within game boundaries
                leftPos = Math.max(10, Math.min(leftPos, sceneWidth - bubbleWidth - 10));
                topPos = Math.max(10, Math.min(topPos, sceneHeight - bubbleHeight - 10));
                
                // Position the bubble
                thoughtBubble.style.left = leftPos + 'px';
                thoughtBubble.style.top = topPos + 'px';
                thoughtBubble.style.display = 'block';
                
                // Clear previous timer
                if (thoughtTimer) clearTimeout(thoughtTimer);
                
                // Mark this Thronglet as the current speaker
                // First clear any previous speaking flags
                for (const t of thronglets) {
                    t.isCurrentlySpeaking = false;
                }
                this.isCurrentlySpeaking = true;
                
                // Show Morse code translation if applicable
                setTimeout(() => {
                    // Check for Morse patterns already present in the text
                    const morsePatterns = extractMorsePatterns(text);
                    
                    // If there are morse patterns, sometimes show the translation
                    if (morsePatterns.length > 0 && Math.random() < 0.4) {
                        const translation = morseToText(morsePatterns[0]);
                        if (translation && thoughtBubble.style.display === 'block') {
                            thoughtBubble.innerHTML = text + `<br><small>(Morse: "${translation}")</small>`;
                        }
                    }
                    // Random chance to inject a Morse code hint for learning
                    else if (this.morsePatterns && this.morsePatterns.length > 0 && Math.random() < 0.3) {
                        const randomPattern = this.morsePatterns[Math.floor(Math.random() * this.morsePatterns.length)];
                        const translation = morseToText(randomPattern);
                        if (translation && thoughtBubble.style.display === 'block') {
                            thoughtBubble.innerHTML = text + `<br><small>(${randomPattern} = "${translation}")</small>`;
                        }
                    }
                }, 500);
                
                // Calculate display time based on text length (at least 3 seconds, more for longer messages)
                const displayTime = Math.max(3000, Math.min(10000, text.length * 100));
                
                // Hide thought bubble after calculated time
                thoughtTimer = setTimeout(() => {
                    thoughtBubble.style.display = 'none';
                    this.isCurrentlySpeaking = false;
                }, displayTime);
            }
            
            // Add method to generate harmonic beep sound
            playBeepSound(text) {
                if (!audioContext) return; // Skip if audio not supported
                
                // Determine which beep pattern to use
                let pattern = null;
                
                // If agent learning is enabled, use the agent to determine beep pattern
                if (agentLearningEnabled && this.agent && this.agent.lastBeepPattern) {
                    pattern = this.agent.lastBeepPattern.pattern;
                } else {
                    // Default pattern based on Thronglet ID
                    pattern = [300 + (this.id * 8) % 40, 0.2];
                }
                
                // Create main oscillator for the beep
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                // Connect nodes
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                // Set frequency based on pattern
                oscillator.frequency.value = pattern[0];
                oscillator.type = 'sine';
                
                // Create a harmonizer oscillator for richer sound
                const harmonizer = audioContext.createOscillator();
                const harmonizerGain = audioContext.createGain();
                
                // Connect harmonizer
                harmonizer.connect(harmonizerGain);
                harmonizerGain.connect(audioContext.destination);
                
                // Set harmonizer to perfect fifth (1.5x frequency)
                harmonizer.frequency.value = pattern[0] * 1.5;
                harmonizer.type = 'sine';
                harmonizerGain.gain.value = 0.08; // Slightly quieter than main tone
                
                // Set volume (quieter than default)
                gainNode.gain.value = 0.15;
                
                // Beep duration from pattern
                const beepDuration = pattern[1]; 
                
                // Fade in slightly
                gainNode.gain.setValueAtTime(0.01, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.15, audioContext.currentTime + 0.05);
                
                // Fade out
                gainNode.gain.setValueAtTime(0.15, audioContext.currentTime + 0.05);
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + beepDuration);
                
                // Same for harmonizer
                harmonizerGain.gain.setValueAtTime(0.01, audioContext.currentTime);
                harmonizerGain.gain.exponentialRampToValueAtTime(0.08, audioContext.currentTime + 0.05);
                harmonizerGain.gain.setValueAtTime(0.08, audioContext.currentTime + 0.05);
                harmonizerGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + beepDuration);
                
                // Start and stop both oscillators
                oscillator.start();
                harmonizer.start();
                oscillator.stop(audioContext.currentTime + beepDuration);
                harmonizer.stop(audioContext.currentTime + beepDuration);
            }
            
            jump() {
                // Add jump animation class
                this.element.classList.add('thronglet-jump');
                
                // Remove the class after animation completes
                setTimeout(() => {
                    this.element.classList.remove('thronglet-jump');
                }, 500);
            }
            
            makeDecisions() {
                if (this.isMoving) return;
                
                // If agent learning is enabled and we have an agent
                if (agentLearningEnabled && this.agent) {
                    // First, check if we should start the learning phase
                    if (observationPhase && observationStartTime === null) {
                        observationStartTime = Date.now();
                    }
                    
                    // Check if observation phase should end
                    if (observationPhase && Date.now() - observationStartTime > observationTime) {
                        observationPhase = false;
                        console.log("Switching from observation to learning phase!");
                    }
                    
                    // Get current state for learning
                    const oldState = this.agent.currentState;
                    const newState = this.agent.getState();
                    
                    // Calculate reward based on state changes
                    const reward = this.agent.calculateReward(oldState, newState);
                    
                    // Update agent learning based on reward
                    this.agent.updateLearning(reward);
                    
                    // Check for teamwork opportunities
                    this.agent.checkTeamworkOpportunities();
                    
                    // Check if beeps got responses
                    this.agent.checkBeepResponses();
                    
                    // Decide on an action
                    const action = this.agent.decideAction();
                    
                    // In observation phase or if no action chosen, use default behavior
                    if (observationPhase || !action) {
                        this.defaultBehavior();
                    } else {
                        // Take the action chosen by the agent
                        this.agent.takeAction(action);
                    }
                } else {
                    // Default AI behavior if agent learning is disabled
                    this.defaultBehavior();
                }
            }
            
            // Default behavior when agent is not making decisions
            defaultBehavior() {
                // Original behavior as fallback
                if (this.hunger < 50 && apples.length > 0) {
                    let closestApple = this.findClosestAvailableItem(apples);
                    if (closestApple) {
                        this.showThought("I'm hungry! Going to get that apple!");
                        this.moveTowards(closestApple.x, closestApple.y);
                        return;
                    }
                }
                
                if (this.happiness < 50 && balls.length > 0 && !isBallMoving) {
                    let closestBall = this.findClosestAvailableItem(balls);
                    if (closestBall) {
                        this.showThought("I need to play with that ball!");
                        this.moveTowards(closestBall.x, closestBall.y);
                        return;
                    }
                }
                
                // Random wandering
                if (Math.random() < 0.3 / thronglets.length) {
                    const borderPadding = 60;
                    const randomX = borderPadding + Math.random() * (sceneWidth - 2 * borderPadding);
                    const randomY = borderPadding + Math.random() * (sceneHeight - 2 * borderPadding);
                    
                    this.showThought("I wonder what's over there...");
                    this.moveTowards(randomX, randomY);
                }
            }
            
            findClosestAvailableItem(items) {
                if (items.length === 0) return null;
                
                let closest = null;
                let closestDistance = Infinity;
                
                for (const item of items) {
                    // Check if another Thronglet is already targeting this item
                    let isTargeted = false;
                    for (const otherThronglet of thronglets) {
                        if (otherThronglet !== this && otherThronglet.isMoving && 
                            otherThronglet.targetX === item.x && otherThronglet.targetY === item.y) {
                            isTargeted = true;
                            break;
                        }
                    }
                    
                    if (isTargeted) continue;
                    
                    const distance = Math.sqrt(
                        Math.pow(this.x - item.x, 2) + 
                        Math.pow(this.y - item.y, 2)
                    );
                    
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closest = item;
                    }
                }
                
                return closest;
            }
            
            remove() {
                if (this.element && this.element.parentNode) {
                    gameScene.removeChild(this.element);
                }
                if (this.multiplyTimeout) {
                    clearTimeout(this.multiplyTimeout);
                }
            }
            
            updateThoughtBubblePosition() {
                const bubbleWidth = 280;
                const bubbleHeight = Math.min(thoughtBubble.textContent.length / 2, 300);
                
                // Determine best position to keep bubble on screen
                let leftPos = this.x - (bubbleWidth / 2);
                let topPos = this.y - bubbleHeight - 30;
                
                // Keep bubble within game boundaries
                leftPos = Math.max(10, Math.min(leftPos, sceneWidth - bubbleWidth - 10));
                topPos = Math.max(10, Math.min(topPos, sceneHeight - bubbleHeight - 10));
                
                // Position the bubble
                thoughtBubble.style.left = leftPos + 'px';
                thoughtBubble.style.top = topPos + 'px';
            }
            
            updateStatsPosition() {
                this.statsElement.style.left = (this.x - 60) + 'px';
                this.statsElement.style.top = (this.y - 100) + 'px';
            }
            
            toggleStats() {
                // Hide all other Thronglet stats first
                for (const t of thronglets) {
                    if (t !== this) {
                        t.statsElement.style.display = 'none';
                    }
                }
                
                // Toggle this Thronglet's stats
                this.statsElement.style.display = 
                    this.statsElement.style.display === 'block' ? 'none' : 'block';
                
                // Update stats display
                this.updateStats();
                
                // Show a thought about learning if agent system is enabled
                if (this.statsElement.style.display === 'block' && agentLearningEnabled && this.agent) {
                    const metrics = this.agent.getIntelligenceMetrics();
                    const totalScore = metrics.intelligenceScore + metrics.teamworkScore + metrics.communicationScore;
                    
                    // Different thoughts based on learning progress
                    if (totalScore < 1) {
                        this.showThought("I'm just starting to learn!");
                    } else if (totalScore < 5) {
                        this.showThought("I'm learning new things every day!");
                    } else if (totalScore < 10) {
                        this.showThought("I'm getting smarter! I understand more now.");
                    } else if (totalScore < 15) {
                        this.showThought("I've learned so much! I know what to do most of the time.");
                    } else {
                        this.showThought("I'm very intelligent now! I understand teamwork and communication.");
                    }
                }
            }
            
            updateStats() {
                // Update hunger level
                this.hungerLevel.style.width = this.hunger + '%';
                this.hungerLevel.style.backgroundColor = 
                    this.hunger > 50 ? '#2ecc71' : this.hunger > 20 ? '#f39c12' : '#e74c3c';
                
                // Update happiness level
                this.happinessLevel.style.width = this.happiness + '%';
                this.happinessLevel.style.backgroundColor = 
                    this.happiness > 50 ? '#2ecc71' : this.happiness > 20 ? '#f39c12' : '#e74c3c';
                
                // Update agent learning stats if agent exists
                if (agentLearningEnabled && this.agent) {
                    // First check if we already created learning stat bars
                    if (!this.intelligenceBar) {
                        // Add intelligence level display
                        const intelligenceLabel = document.createElement('div');
                        intelligenceLabel.className = 'stat-label';
                        intelligenceLabel.textContent = 'Intelligence:';
                        this.statsElement.appendChild(intelligenceLabel);
                        
                        const intelligenceBarContainer = document.createElement('div');
                        intelligenceBarContainer.className = 'thronglet-intelligence-bar';
                        intelligenceBarContainer.style.width = '100%';
                        intelligenceBarContainer.style.height = '10px';
                        intelligenceBarContainer.style.margin = '3px 0';
                        intelligenceBarContainer.style.backgroundColor = '#333';
                        intelligenceBarContainer.style.borderRadius = '3px';
                        intelligenceBarContainer.style.overflow = 'hidden';
                        
                        this.intelligenceBar = document.createElement('div');
                        this.intelligenceBar.className = 'thronglet-intelligence-level';
                        this.intelligenceBar.style.height = '100%';
                        this.intelligenceBar.style.width = '0%';
                        this.intelligenceBar.style.backgroundColor = '#9b59b6';
                        this.intelligenceBar.style.transition = 'width 0.5s ease';
                        
                        intelligenceBarContainer.appendChild(this.intelligenceBar);
                        this.statsElement.appendChild(intelligenceBarContainer);
                        
                        // Add teamwork level display
                        const teamworkLabel = document.createElement('div');
                        teamworkLabel.className = 'stat-label';
                        teamworkLabel.textContent = 'Teamwork:';
                        this.statsElement.appendChild(teamworkLabel);
                        
                        const teamworkBarContainer = document.createElement('div');
                        teamworkBarContainer.className = 'thronglet-teamwork-bar';
                        teamworkBarContainer.style.width = '100%';
                        teamworkBarContainer.style.height = '10px';
                        teamworkBarContainer.style.margin = '3px 0';
                        teamworkBarContainer.style.backgroundColor = '#333';
                        teamworkBarContainer.style.borderRadius = '3px';
                        teamworkBarContainer.style.overflow = 'hidden';
                        
                        this.teamworkBar = document.createElement('div');
                        this.teamworkBar.className = 'thronglet-teamwork-level';
                        this.teamworkBar.style.height = '100%';
                        this.teamworkBar.style.width = '0%';
                        this.teamworkBar.style.backgroundColor = '#3498db';
                        this.teamworkBar.style.transition = 'width 0.5s ease';
                        
                        teamworkBarContainer.appendChild(this.teamworkBar);
                        this.statsElement.appendChild(teamworkBarContainer);
                        
                        // Add communication level display
                        const communicationLabel = document.createElement('div');
                        communicationLabel.className = 'stat-label';
                        communicationLabel.textContent = 'Communication:';
                        this.statsElement.appendChild(communicationLabel);
                        
                        const communicationBarContainer = document.createElement('div');
                        communicationBarContainer.className = 'thronglet-communication-bar';
                        communicationBarContainer.style.width = '100%';
                        communicationBarContainer.style.height = '10px';
                        communicationBarContainer.style.margin = '3px 0';
                        communicationBarContainer.style.backgroundColor = '#333';
                        communicationBarContainer.style.borderRadius = '3px';
                        communicationBarContainer.style.overflow = 'hidden';
                        
                        this.communicationBar = document.createElement('div');
                        this.communicationBar.className = 'thronglet-communication-level';
                        this.communicationBar.style.height = '100%';
                        this.communicationBar.style.width = '0%';
                        this.communicationBar.style.backgroundColor = '#e67e22';
                        this.communicationBar.style.transition = 'width 0.5s ease';
                        
                        communicationBarContainer.appendChild(this.communicationBar);
                        this.statsElement.appendChild(communicationBarContainer);
                    }
                    
                    // Get agent metrics
                    const metrics = this.agent.getIntelligenceMetrics();
                    
                    // Update the bars based on intelligence growth (max 10 for each)
                    const maxScore = 10;
                    const intelligencePercent = Math.min(100, (metrics.intelligenceScore / maxScore) * 100);
                    const teamworkPercent = Math.min(100, (metrics.teamworkScore / maxScore) * 100);
                    const communicationPercent = Math.min(100, (metrics.communicationScore / maxScore) * 100);
                    
                    this.intelligenceBar.style.width = intelligencePercent + '%';
                    this.teamworkBar.style.width = teamworkPercent + '%';
                    this.communicationBar.style.width = communicationPercent + '%';
                }
            }
            
            // Add new method for conversations
            checkForConversation() {
                // Don't start conversations if already in one or in creator meeting
                if (isCreatorMeeting || isThrongletChatting || this.isMoving) return;
                
                // Check cooldown
                const currentTime = Date.now();
                if (currentTime - lastChatTime < chatCooldown) return;
                
                // Find nearby Thronglets to chat with
                const nearbyThronglet = this.findNearbyThronglet();
                if (nearbyThronglet) {
                    // Start a conversation
                    this.startConversation(nearbyThronglet);
                }
            }
            
            findNearbyThronglet() {
                const maxDistance = 100; // Maximum distance for conversation
                let closestThronglet = null;
                let closestDistance = maxDistance;
                
                for (const otherThronglet of thronglets) {
                    if (otherThronglet === this || otherThronglet.isMoving) continue;
                    
                    const distance = Math.sqrt(
                        Math.pow(this.x - otherThronglet.x, 2) + 
                        Math.pow(this.y - otherThronglet.y, 2)
                    );
                    
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestThronglet = otherThronglet;
                    }
                }
                
                return closestThronglet;
            }
            
            startConversation(otherThronglet) {
                isThrongletChatting = true;
                lastChatTime = Date.now();
                
                // Create conversation key
                const conversationKey = `${Math.min(this.id, otherThronglet.id)}_${Math.max(this.id, otherThronglet.id)}`;
                
                // Initialize conversation context
                if (!ongoingConversations[conversationKey]) {
                    ongoingConversations[conversationKey] = [];
                }
                
                // Generate conversation starter
                const myState = {
                    hunger: this.hunger,
                    happiness: this.happiness
                };
                
                const otherState = {
                    hunger: otherThronglet.hunger,
                    happiness: otherThronglet.happiness
                };
                
                const conversationContext = ongoingConversations[conversationKey].length > 0 
                    ? ongoingConversations[conversationKey].slice(-3).map(msg => `${msg.speaker}: ${msg.text}`).join("\n")
                    : "";
                
                const conversationPrompt = `You are Thronglet #${this.id} talking to Thronglet #${otherThronglet.id}. 
                Your hunger is ${myState.hunger}% and happiness is ${myState.happiness}%.
                The other Thronglet's hunger is ${otherState.hunger}% and happiness is ${otherState.happiness}%.
                
                ${ongoingConversations[conversationKey].length > 0 ? 
                    `This is a continuation of a conversation. Here's what was said before:\n${conversationContext}` :
                    `You are starting a new conversation. You can talk about food, games, life as a Thronglet, or anything cute and friendly.`}
                
                Generate a short (maximum 15 words) message to say to the other Thronglet.`;
                
                // First Thronglet speaks
                queueLlmConversationRequest(conversationPrompt, this, otherThronglet, conversationKey);
            }
            
            // Generate a unique personality for this Thronglet
            generatePersonality() {
                const traits = [
                    ["playful", "serious", "curious", "cautious", "energetic", "calm"],
                    ["friendly", "shy", "social", "independent", "affectionate", "reserved"],
                    ["optimistic", "pessimistic", "thoughtful", "impulsive", "patient", "eager"]
                ];
                
                // Select one trait from each category based on ID to ensure consistency
                const personalityTraits = traits.map((category, i) => 
                    category[(this.id + i) % category.length]
                );
                
                // Add a primary color preference based on ID
                const colors = ["red", "blue", "green", "yellow", "purple", "orange", "pink"];
                const favoriteColor = colors[this.id % colors.length];
                
                // Add a food preference
                const foods = ["apples", "berries", "cookies", "candies", "nuts", "seeds"];
                const favoriteFood = foods[this.id % foods.length];
                
                return {
                    traits: personalityTraits,
                    favoriteColor: favoriteColor,
                    favoriteFood: favoriteFood
                };
            }
        }
        
        function updateThrongletCounter() {
            message.textContent = `Thronglets: ${thronglets.length}`;
        }
        
        function startThrongletAI() {
            // Create the first Thronglet
            const firstThronglet = new Thronglet(sceneWidth / 2, sceneHeight / 2);
            thronglets.push(firstThronglet);
            updateThrongletCounter();
            
            // IMMEDIATELY TEACH ALL CONCEPTS TO THE FIRST THRONGLET (CREATOR)
            // This guarantees the creator Thronglet can act as a teacher to others
            console.log("Teaching all concepts to Creator Thronglet (id: 0)");
            const creatorConcepts = ["food", "happy", "sad", "follow"];
            
            // First ensure the knownConcepts array is initialized
            if (!firstThronglet.knownConcepts) {
                firstThronglet.knownConcepts = [];
                firstThronglet.lastConceptUse = {};
            }
            
            // Then teach all concepts directly
            for (const concept of creatorConcepts) {
                // Directly add the concept (don't rely on learnConcept method)
                if (!firstThronglet.knownConcepts.includes(concept)) {
                    firstThronglet.knownConcepts.push(concept);
                    console.log(`Creator Thronglet learned concept: ${concept} (direct)`);
                    
                    // Add to neural network immediately
                    if (typeof integrateConceptToNeuralNetwork === 'function') {
                        integrateConceptToNeuralNetwork(firstThronglet, concept);
                    }
                    
                    // Display the concept to show it's active
                    const pattern = throngletLanguage.getPatternForConcept(concept);
                    setTimeout(() => {
                        firstThronglet.showThought(pattern);
                    }, 500 * creatorConcepts.indexOf(concept));
                }
            }
            
            // Also give it all Morse patterns
            if (!firstThronglet.morsePatterns) {
                firstThronglet.morsePatterns = [];
                // Add Morse patterns for all concepts
                for (const concept of creatorConcepts) {
                    const pattern = throngletLanguage.getPatternForConcept(concept);
                    if (pattern && !firstThronglet.morsePatterns.includes(pattern)) {
                        firstThronglet.morsePatterns.push(pattern);
                    }
                }
            }
            
            // Start the game loop
            gameLoop();
            
            // Start status management
            setInterval(() => {
                if (gameActive) {
                    for (const thronglet of thronglets) {
                        thronglet.decreaseHunger();
                        thronglet.decreaseHappiness();
                        thronglet.updateWellBeing();
                        thronglet.makeDecisions();
                        
                        // Update stats display if visible
                        if (thronglet.statsElement.style.display === 'block') {
                            thronglet.updateStats();
                        }
                    }
                }
            }, 5000);
            
            // Start walking animation
            walkAnimationTimer = setInterval(() => {
                if (gameActive) {
                    for (const thronglet of thronglets) {
                        thronglet.animateWalking();
                    }
                }
            }, 300);
            
            // Start conversation checks
            setInterval(() => {
                if (gameActive && !isCreatorMeeting && !isThrongletChatting && thronglets.length > 1) {
                    // Choose a random Thronglet to initiate conversation
                    const randomIndex = Math.floor(Math.random() * thronglets.length);
                    thronglets[randomIndex].checkForConversation();
                }
            }, 10000); // Check for conversation opportunities every 10 seconds

            // Start apple tree update cycle
            setInterval(() => {
                if (gameActive) {
                    updateAppleTrees();
                }
            }, 1000); // Update apple trees every second
            
            // Apple trees will only be created when the user places them
            
            // Initialize agent learning system if enabled
            if (agentLearningEnabled) {
                setupAgentLearningSystem();
            }
        }
        
        egg.addEventListener('click', () => {
            clicks++;
            
            // Initialize audio context on first interaction
            if (!audioContext) {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.warn("Web Audio API not supported in this browser");
                }
            }
            
            // Add shake animation
            egg.classList.add('shake');
            setTimeout(() => {
                egg.classList.remove('shake');
            }, 500);
            
            if (clicks === 1) {
                egg.classList.add('crack1');
                message.textContent = "The egg is cracking... Click again!";
            } 
            else if (clicks === 2) {
                egg.classList.add('crack2');
                message.textContent = "One more click to hatch!";
            }
            else if (clicks === 3) {
                // Hatch the egg!
                egg.style.display = 'none';
                
                // Hide the placeholder thronglet element
                thronglet.style.display = 'none';
                
                // Show UI elements
                commandCenter.style.display = 'block';
                itemButtons.style.display = 'block';
                
                // Start the game
                gameActive = true;
                message.textContent = "Your Thronglet is hatching!";
                
                // Create the first Thronglet with a slight delay for effect
                setTimeout(() => {
                    startThrongletAI();
                    
                    // Make sure memory is initialized after the first Thronglet is created
                    setTimeout(() => {
                        ensureAllThrongletsHaveMemory();
                        console.log("Memory initialized for starting Thronglet");
                    }, 1000);
                }, 500);
            }
        });
        
        function gameLoop() {
            if (!gameActive) return;
            
            // Update all Thronglets
            for (const thronglet of thronglets) {
                thronglet.updatePosition();
            }
            
            requestAnimationFrame(gameLoop);
        }

        // Create trees around the border
        function createTrees() {
            const treeSpacing = 40; // Space between trees
            const borderPadding = 20; // Padding from the edge
            
            // Top row of trees
            for (let x = borderPadding; x < sceneWidth - borderPadding; x += treeSpacing) {
                createTree(x, borderPadding);
            }
            
            // Bottom row of trees
            for (let x = borderPadding; x < sceneWidth - borderPadding; x += treeSpacing) {
                createTree(x, sceneHeight - borderPadding - 20);
            }
            
            // Left column of trees
            for (let y = borderPadding + treeSpacing; y < sceneHeight - borderPadding - treeSpacing; y += treeSpacing) {
                createTree(borderPadding, y);
            }
            
            // Right column of trees
            for (let y = borderPadding + treeSpacing; y < sceneHeight - borderPadding - treeSpacing; y += treeSpacing) {
                createTree(sceneWidth - borderPadding - 20, y);
            }
        }

        function createTree(x, y) {
            const tree = document.createElement('div');
            tree.className = 'tree';
            tree.style.left = x + 'px';
            tree.style.top = y + 'px';
            gameScene.appendChild(tree);
        }
        
        function createApple(x, y) {
            const apple = document.createElement('div');
            apple.className = 'apple';
            apple.style.left = x + 'px';
            apple.style.top = y + 'px';
            gameScene.appendChild(apple);
            apples.push({
                element: apple,
                x: x,
                y: y
            });
            
            // Track apple placement in global context
            trackEvent('apple_placed', {
                position: { x, y },
                totalApples: apples.length
            });
            
            // Notify a random Thronglet about the new apple
            if (thronglets.length > 0 && isLlmEnabled) {
                const randomIndex = Math.floor(Math.random() * thronglets.length);
                const randomThronglet = thronglets[randomIndex];
                
                const prompt = `You are Thronglet #${randomThronglet.id}. Your hunger level is ${randomThronglet.hunger}% and happiness level is ${randomThronglet.happiness}%. The human has just placed a delicious apple in the game area. How do you react?`;
                
                queueLlmRequest(prompt, randomThronglet);
            }
            
            return apple;
        }
        
        function createBall(x, y) {
            const ball = document.createElement('div');
            ball.className = 'ball';
            ball.style.left = x + 'px';
            ball.style.top = y + 'px';
            gameScene.appendChild(ball);
            balls.push({
                element: ball,
                x: x,
                y: y,
                lastKickedBy: null, // Track the last thronglet that kicked this ball
                lastKickTime: null  // Track when the ball was last kicked
            });
            
            // Track ball placement in global context
            trackEvent('ball_placed', {
                position: { x, y },
                totalBalls: balls.length
            });
            
            // Notify a random Thronglet about the new ball
            if (thronglets.length > 0 && isLlmEnabled) {
                const randomIndex = Math.floor(Math.random() * thronglets.length);
                const randomThronglet = thronglets[randomIndex];
                
                const prompt = `You are Thronglet #${randomThronglet.id}. Your hunger level is ${randomThronglet.hunger}% and happiness level is ${randomThronglet.happiness}%. The human has just placed a fun bouncy ball in the game area. How do you react?`;
                
                queueLlmRequest(prompt, randomThronglet);
            }
            
            return ball;
        }

        function moveBall() {
            if (!isBallMoving || !activeBall) return;
            
            // Check that ball element still exists
            if (!activeBall.element || !activeBall.element.parentNode) {
                console.log("Ball element no longer exists, stopping ball movement");
                isBallMoving = false;
                activeBall = null;
                return;
            }
            
            // Update ball position based on velocity
            activeBall.x += ballVelocityX;
            activeBall.y += ballVelocityY;
            
            // Apply friction to slow down the ball
            ballVelocityX *= 0.95;
            ballVelocityY *= 0.95;
            
            // Update ball position on screen - with safety check
            if (activeBall.element) {
                activeBall.element.style.left = activeBall.x + 'px';
                activeBall.element.style.top = activeBall.y + 'px';
            }
            
            // Check for collisions with edges
            const ballSize = 25; // Ball width/height
            const borderPadding = 40;
            
            // Bounce off left/right borders
            if (activeBall.x <= borderPadding || activeBall.x >= sceneWidth - borderPadding - ballSize) {
                ballVelocityX = -ballVelocityX * 0.7; // Reverse direction and reduce speed
                
                // Keep ball within bounds
                if (activeBall.x <= borderPadding) {
                    activeBall.x = borderPadding + 1;
                } else {
                    activeBall.x = sceneWidth - borderPadding - ballSize - 1;
                }
            }
            
            // Bounce off top/bottom borders
            if (activeBall.y <= borderPadding || activeBall.y >= sceneHeight - borderPadding - ballSize) {
                ballVelocityY = -ballVelocityY * 0.7; // Reverse direction and reduce speed
                
                // Keep ball within bounds
                if (activeBall.y <= borderPadding) {
                    activeBall.y = borderPadding + 1;
                } else {
                    activeBall.y = sceneHeight - borderPadding - ballSize - 1;
                }
            }
            
            // Check if ball has stopped
            if (Math.abs(ballVelocityX) < 0.1 && Math.abs(ballVelocityY) < 0.1) {
                ballVelocityX = 0;
                ballVelocityY = 0;
                isBallMoving = false;
                activeBall = null;
                return;
            }
            
            // Continue animation
            requestAnimationFrame(moveBall);
        }

        // Create trees
        createTrees();
        
        // Add event listeners for placing items
        placeApple.addEventListener('click', () => {
            isPlacingApple = true;
            isPlacingBall = false;
            message.textContent = "Click in the game area to place an apple.";
        });
        
        placeBall.addEventListener('click', () => {
            isPlacingApple = false;
            isPlacingBall = true;
            message.textContent = "Click in the game area to place a ball.";
        });
        
        // Add click handler for placing items
        gameScene.addEventListener('click', (e) => {
            // Close all Thronglet stats if clicking on the background
            const clickedElement = e.target;
            // If the click is directly on the game scene (not on a Thronglet or other element)
            if (clickedElement === gameScene) {
                // Hide all Thronglet stats
                for (const thronglet of thronglets) {
                    thronglet.statsElement.style.display = 'none';
                }
            }
            
            if (isPlacingApple) {
                const rect = gameScene.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                createApple(x, y);
                isPlacingApple = false;
                message.textContent = "Apple placed! Your Thronglets will eat it when hungry.";
            }
            else if (isPlacingBall) {
                const rect = gameScene.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                createBall(x, y);
                isPlacingBall = false;
                message.textContent = "Ball placed! Your Thronglets can play with it.";
            }
            // Add the apple tree placement case:
            else if (isPlacingAppleTree) {
                const rect = gameScene.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // Check if we can place more apple trees
                if (appleTrees.length < maxAppleTrees) {
                    createAppleTree(x, y);
                    isPlacingAppleTree = false;
                    message.textContent = "Apple tree planted! It will periodically drop apples.";
                } else {
                    isPlacingAppleTree = false;
                    message.textContent = `Maximum of ${maxAppleTrees} apple trees reached!`;
                }
            }
        });
        
        // Add command button handlers - removed because button no longer exists
        // startMeeting.addEventListener('click', () => {
        //     if (!isCreatorMeeting) {
        //         startCreatorMeeting();
        //     } else {
        //         message.textContent = "A meeting is already in progress.";
        //     }
        // });
        
        // Setup LLM integration
        setupLlmIntegration();

        async function callFireworksLLM(prompt, thronglet, isCreatorConversation = false, isThrongletConversation = false) {
            // Learning agent has replaced the LLM system
            console.log("LLM has been replaced by learning agent system");
            return { 
                speech: "I'm thinking for myself now!",
                action: "wander"
            };
        }

        function queueLlmRequest(prompt, thronglet, isCreatorConversation = false) {
            // Learning agent has replaced the LLM system
            if (thronglet && thronglet.agent) {
                // Let the agent decide
                thronglet.makeDecisions();
            } else {
                // Default behavior
                thronglet.showThought("I'm learning to think for myself!");
            }
        }
        
        async function processLlmQueue() {
            // Learning agent has replaced the LLM system
            console.log("LLM queue processing has been replaced by learning agent system");
        }

        function handleThrongletAction(thronglet, action) {
            action = action.toLowerCase();
            
            if (action.includes("wander")) {
                // Random wandering
                const borderPadding = 60;
                const randomX = borderPadding + Math.random() * (sceneWidth - 2 * borderPadding);
                const randomY = borderPadding + Math.random() * (sceneHeight - 2 * borderPadding);
                thronglet.moveTowards(randomX, randomY);
            }
            else if (action.includes("seek_food") || action.includes("food")) {
                // Find food
                let closestApple = thronglet.findClosestAvailableItem(apples);
                if (closestApple) {
                    thronglet.moveTowards(closestApple.x, closestApple.y);
                }
            }
            else if (action.includes("seek_play") || action.includes("play")) {
                // Find ball
                let closestBall = thronglet.findClosestAvailableItem(balls);
                if (closestBall) {
                    thronglet.moveTowards(closestBall.x, closestBall.y);
                }
            }
            else if (action.includes("multiply")) {
                // Try to multiply if conditions allow
                const currentTime = Date.now();
                if (currentTime - thronglet.lastMultiplyTime >= 30000 && thronglet.canMultiply && thronglets.length < 5) {
                    thronglet.multiply();
                }
            }
            else if (action.includes("suggest")) {
                // Thronglet wants to suggest a feature
                const suggestionPrompt = `You are Thronglet #${thronglet.id}. You want to suggest a fun new feature for the game. What specific feature would you suggest? (Keep it under 15 words)`;
                queueLlmRequest(suggestionPrompt, thronglet);
            }
        }

        function setupLlmIntegration() {
            // Create a status indicator
            const statusLabel = document.createElement('div');
            statusLabel.textContent = 'Learning AI System Enabled';
            statusLabel.style.color = 'white';
            statusLabel.style.backgroundColor = '#8e44ad'; // Purple for new system
            statusLabel.style.padding = '8px 15px';
            statusLabel.style.borderRadius = '5px';
            statusLabel.style.margin = '10px auto';
            statusLabel.style.width = 'fit-content';
            
            // Feature suggestions display button
            const suggestionsButton = document.createElement('button');
            suggestionsButton.textContent = 'View Feature Suggestions';
            suggestionsButton.style.padding = '8px 15px';
            suggestionsButton.style.backgroundColor = '#3498db';
            suggestionsButton.style.color = 'white';
            suggestionsButton.style.border = 'none';
            suggestionsButton.style.borderRadius = '5px';
            suggestionsButton.style.cursor = 'pointer';
            suggestionsButton.style.display = 'block';
            suggestionsButton.style.margin = '5px auto';
            
            suggestionsButton.addEventListener('click', () => {
                const features = localStorage.getItem("throngletFeatures") || "No features suggested yet.";
                alert(features);
            });

            // Add context view button
            const contextButton = document.createElement('button');
            contextButton.textContent = 'View Thronglet Memory';
            contextButton.style.padding = '8px 15px';
            contextButton.style.backgroundColor = '#9b59b6';
            contextButton.style.color = 'white';
            contextButton.style.border = 'none';
            contextButton.style.borderRadius = '5px';
            contextButton.style.cursor = 'pointer';
            contextButton.style.display = 'block';
            contextButton.style.margin = '5px auto';
            
            contextButton.addEventListener('click', () => {
                if (thronglets.length === 0) {
                    alert("No Thronglets available yet. Hatch the egg first!");
                    return;
                }
                
                // Initialize memory for all Thronglets if missing
                ensureAllThrongletsHaveMemory();
                
                // Simple display version
                const activeThronglet = thronglets.length > 0 ? thronglets[0] : null;
                
                if (activeThronglet) {
                    const memories = globalContext.throngletMemory[activeThronglet.id] || [];
                    if (memories.length === 0) {
                        alert(`No memories found for Thronglet #${activeThronglet.id}. Adding initialization memory...`);
                        
                        // Add an initial memory if none exists
                        addThrongletMemory(activeThronglet.id, 'system', 'Memory system initialized');
                        addThrongletMemory(activeThronglet.id, 'birth', 'I was hatched from an egg');
                        
                        alert(`Memory initialized for Thronglet #${activeThronglet.id}. Click View Memory again.`);
                    } else {
                        let memoryText = `Thronglet #${activeThronglet.id} Memory:\n\n`;
                        
                        // Sort by newest first
                        const sortedMemories = [...memories].sort((a, b) => b.timestamp - a.timestamp);
                        
                        sortedMemories.forEach(m => {
                            const date = new Date(m.timestamp);
                            memoryText += `${date.toLocaleTimeString()}: ${m.type} - ${m.content}\n`;
                        });
                        
                        alert(memoryText);
                    }
            } else {
                    alert("No Thronglets available");
                }
            });
            
            // Add a helper function to ensure all Thronglets have memory initialized
            // Add this after loadFeaturesFromStorage

            function ensureAllThrongletsHaveMemory() {
                console.log("Ensuring all Thronglets have memory initialized");
                
                // Make sure globalContext has throngletMemory
                if (!globalContext) {
                    globalContext = {
                        gameStartTime: Date.now(),
                        sessionEvents: [],
                        throngletMemory: {},
                        appleHistory: [],
                        ballHistory: [],
                        creatorInteractions: []
                    };
                }
                
                if (!globalContext.throngletMemory) {
                    globalContext.throngletMemory = {};
                }
                
                // Initialize memory for all Thronglets
                thronglets.forEach(thronglet => {
                    if (!globalContext.throngletMemory[thronglet.id]) {
                        globalContext.throngletMemory[thronglet.id] = [];
                        
                        // Add a birth memory if none exists
                        if (thronglet.parentId === null) {
                            addThrongletMemory(thronglet.id, 'birth', 'I hatched from an egg brought by the Creator.');
            } else {
                            addThrongletMemory(thronglet.id, 'birth', `I was created when Thronglet #${thronglet.parentId} multiplied.`);
                        }
                        
                        console.log(`Initialized memory for Thronglet #${thronglet.id}`);
                    }
                });
                
                // Force save
                saveContextToStorage();
            }

            // Add elements to the game container
            const container = document.getElementById('game-container');
            container.appendChild(statusLabel);
            container.appendChild(contextButton);
            
            // Add reset button
            const resetButton = document.createElement('button');
            resetButton.textContent = 'RESET EVERYTHING';
            resetButton.style.padding = '8px 15px';
            resetButton.style.backgroundColor = '#e74c3c';
            resetButton.style.color = 'white';
            resetButton.style.border = 'none';
            resetButton.style.borderRadius = '5px';
            resetButton.style.cursor = 'pointer';
            resetButton.style.display = 'block';
            resetButton.style.margin = '15px auto 5px auto';
            resetButton.style.fontWeight = 'bold';
            
            // Add warning dialogue
            resetButton.addEventListener('click', () => {
                if (confirm("⚠️ WARNING: This will erase ALL game data including:\n\n- All Thronglet memories\n- Feature suggestions\n- Conversation history\n- Game state\n\nAre you sure you want to completely reset the game?")) {
                    resetEverything();
                }
            });
            
            container.appendChild(resetButton);
            
            // Add learning stats button
            if (agentLearningEnabled) {
                const learningStatsButton = document.createElement('button');
                learningStatsButton.textContent = 'View Learning Stats';
                learningStatsButton.style.padding = '8px 15px';
                learningStatsButton.style.backgroundColor = '#2980b9';
                learningStatsButton.style.color = 'white';
                learningStatsButton.style.border = 'none';
                learningStatsButton.style.borderRadius = '5px';
                learningStatsButton.style.cursor = 'pointer';
                learningStatsButton.style.display = 'block';
                learningStatsButton.style.margin = '5px auto';
                
                learningStatsButton.addEventListener('click', showLearningStats);
                container.appendChild(learningStatsButton);
            }

            // Add brain visualizer button
            if (agentLearningEnabled) {
                const brainVisualizerButton = document.createElement('button');
                brainVisualizerButton.textContent = 'Brain Visualizer';
                brainVisualizerButton.style.padding = '8px 15px';
                brainVisualizerButton.style.backgroundColor = '#16a085';
                brainVisualizerButton.style.color = 'white';
                brainVisualizerButton.style.border = 'none';
                brainVisualizerButton.style.borderRadius = '5px';
                brainVisualizerButton.style.cursor = 'pointer';
                brainVisualizerButton.style.display = 'block';
                brainVisualizerButton.style.margin = '5px auto';
                
                brainVisualizerButton.addEventListener('click', openBrainVisualizer);
                container.appendChild(brainVisualizerButton);
            }
            
            // Initialize communication interface
            initCommunicationInterface();
        }

        // Communication interface functionality
        function initCommunicationInterface() {
            const toggleCommunicationBtn = document.getElementById('toggle-communication');
            const communicationInterface = document.getElementById('communication-interface');
            const messageInput = document.getElementById('message-input');
            const messageTarget = document.getElementById('message-target');
            const sendMessageBtn = document.getElementById('send-message');
            const useMorseCheckbox = document.getElementById('use-morse');
            const morsePreview = document.getElementById('morse-preview');
            
            if (!toggleCommunicationBtn || !communicationInterface) {
                console.warn("Communication interface elements not found");
                return;
            }
            
            // Toggle communication interface visibility
            toggleCommunicationBtn.addEventListener('click', () => {
                const isVisible = communicationInterface.style.display === 'block';
                communicationInterface.style.display = isVisible ? 'none' : 'block';
                
                if (!isVisible) {
                    // Update Thronglet selector when showing the interface
                    updateThrongletSelector();
                    messageInput.focus();
                }
            });
            
            // Update Thronglet selector dropdown with current Thronglets
            function updateThrongletSelector() {
                // Clear existing options except "All Thronglets"
                while (messageTarget.options.length > 1) {
                    messageTarget.remove(1);
                }
                
                // Add option for each Thronglet
                thronglets.forEach(thronglet => {
                    const option = document.createElement('option');
                    option.value = thronglet.id;
                    option.textContent = `Thronglet #${thronglet.id}`;
                    messageTarget.appendChild(option);
                });
            }
            
            // Send message to Thronglets
            sendMessageBtn.addEventListener('click', sendMessage);
            
            // Allow pressing Enter to send message
            messageInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    sendMessage();
                }
            });
            
            // Update Morse preview as user types
            messageInput.addEventListener('input', updateMorsePreview);
            
            // Update Morse preview when checkbox changes
            useMorseCheckbox.addEventListener('change', updateMorsePreview);
            
            // Function to send message to Thronglets
            function sendMessage() {
                const message = messageInput.value.trim();
                
                // Make sure we have a message to send
                if (!message) {
                    alert('Please enter a message to send.');
                    return;
                }
                
                // Get target Thronglet ID
                const targetId = messageTarget.value;
                
                // Convert to morse if option is checked
                const useMorse = useMorseCheckbox.checked;
                const morseMessage = useMorse ? textToMorse(message) : message;
                
                // Track user message in global context
                trackEvent('user_message', {
                    message: message,
                    target: targetId,
                    usedMorse: useMorse
                });
                
                // Find target Thronglets
                let targetThronglets = [];
                if (targetId === 'all') {
                    targetThronglets = thronglets;
                } else {
                    const thronglet = thronglets.find(t => t.id.toString() === targetId);
                    if (thronglet) {
                        targetThronglets = [thronglet];
                    }
                }
                
                // Send message to each target Thronglet
                if (targetThronglets.length > 0) {
                    targetThronglets.forEach(thronglet => {
                        // Add user message to Thronglet's memory
                        addThrongletMemory(thronglet.id, 'received_message', `The Creator sent me: "${message}"`);
                        
                        // Display message in thought bubble
                        const displayMessage = useMorse ? morseMessage : `Message from Creator: ${message}`;
                        thronglet.showThought(displayMessage);
                        
                        // Play Morse code if enabled
                        if (useMorse && audioContext) {
                            const frequency = 300 + (thronglet.id * 10); // Unique frequency per Thronglet
                            playMorseSequence(thronglet, [morseMessage], frequency);
                        }
                        
                        // Have the Thronglet respond
                        setTimeout(() => {
                            respondToMessage(thronglet, message);
                        }, 2000 + Math.random() * 1000); // Random delay for natural feel
                    });
                    
                    // Clear the input field
                    messageInput.value = '';
                    morsePreview.textContent = '';
                } else {
                    alert('No Thronglets available to receive your message.');
                }
            }
            
            // Update Morse preview
            function updateMorsePreview() {
                if (useMorseCheckbox.checked) {
                    const text = messageInput.value.trim();
                    if (text) {
                        morsePreview.textContent = textToMorse(text);
                    } else {
                        morsePreview.textContent = '';
                    }
                } else {
                    morsePreview.textContent = '';
                }
            }
            
            // Thronglet response to user message
            function respondToMessage(thronglet, message) {
                // Base response on message content and Thronglet's state
                let response = '';
                
                // Check if the message is in morse code
                const morsePatterns = extractMorsePatterns(message);
                if (morsePatterns.length > 0) {
                    // Thronglet tries to decode the morse
                    const translation = morseToText(morsePatterns[0]);
                    
                    if (translation) {
                        // Thronglet understood the morse code
                        response = `${morsePatterns[0]} means "${translation}"! I understand!`;
                        
                        // Add this morse pattern to Thronglet's knowledge
                        if (!thronglet.morsePatterns) {
                            thronglet.morsePatterns = [];
                        }
                        if (!thronglet.morsePatterns.includes(morsePatterns[0])) {
                            thronglet.morsePatterns.push(morsePatterns[0]);
                            
                            // Show learning animation
                            showLearningSparkle(thronglet.x, thronglet.y, "Learned Morse!");
                        }
                    } else {
                        // Thronglet doesn't understand completely
                        response = `I hear your beeps! I'm learning this code.`;
                        
                        // Still learn the pattern without translation
                        if (!thronglet.morsePatterns) {
                            thronglet.morsePatterns = [];
                        }
                        if (!thronglet.morsePatterns.includes(morsePatterns[0])) {
                            thronglet.morsePatterns.push(morsePatterns[0]);
                        }
                    }
                    
                    // Respond with a morse pattern too sometimes
                    if (thronglet.morsePatterns && thronglet.morsePatterns.length > 0 && Math.random() < 0.5) {
                        const randomPattern = thronglet.morsePatterns[Math.floor(Math.random() * thronglet.morsePatterns.length)];
                        response += ` ${randomPattern}`;
                    }
                } else {
                    // Message was in plain text - respond based on content
                    const messageLower = message.toLowerCase();
                    
                    // Basic responses based on common questions/commands
                    if (messageLower.includes('hello') || messageLower.includes('hi')) {
                        response = `Hello Creator! I'm Thronglet #${thronglet.id}!`;
                    } else if (messageLower.includes('hungry') || messageLower.includes('food') || messageLower.includes('eat')) {
                        response = thronglet.hunger > 70 
                            ? `I'm feeling full (${thronglet.hunger}%)!` 
                            : `Yes, I'm getting hungry (${thronglet.hunger}%)... Could I have some food?`;
                    } else if (messageLower.includes('happy') || messageLower.includes('sad') || messageLower.includes('how are you')) {
                        response = thronglet.happiness > 70 
                            ? `I'm very happy (${thronglet.happiness}%)!` 
                            : `I'm feeling a bit down (${thronglet.happiness}%)... Playing helps!`;
                    } else if (messageLower.includes('play') || messageLower.includes('ball') || messageLower.includes('game')) {
                        response = `I love playing with the ball! It makes me so happy!`;
                    } else if (messageLower.includes('multiply') || messageLower.includes('friend') || messageLower.includes('more')) {
                        response = thronglets.length < 5 
                            ? `Yes, I'd love to multiply and make more friends!` 
                            : `We're already ${thronglets.length} Thronglets! It's getting crowded!`;
                    } else {
                        // Generic responses for other messages
                        const genericResponses = [
                            `I understand, Creator!`,
                            `Thank you for talking to me!`,
                            `I'm learning every day!`,
                            `It's nice to communicate with you!`,
                            `I'll remember what you said!`
                        ];
                        response = genericResponses[Math.floor(Math.random() * genericResponses.length)];
                    }
                    
                    // Sometimes add a morse code pattern to teach the user
                    if (thronglet.morsePatterns && thronglet.morsePatterns.length > 0 && Math.random() < 0.3) {
                        const randomPattern = thronglet.morsePatterns[Math.floor(Math.random() * thronglet.morsePatterns.length)];
                        const translation = morseToText(randomPattern);
                        response += ` Here's some morse: ${randomPattern}${translation ? ` (means "${translation}")` : ''}`;
                    }
                }
                
                // Add memory of response
                addThrongletMemory(thronglet.id, 'sent_response', `I responded: "${response}"`);
                
                // Show response
                thronglet.showThought(response);
            }
        }

        function checkForFeatureSuggestion(text, throngletId) {
            // Check for suggestion keywords
            const suggestionKeywords = ["suggest", "feature", "add", "idea", "would be cool", "would be nice"];
            const voteKeywords = ["vote", "agree", "like that", "good idea", "+1"];
            
            const textLower = text.toLowerCase();
            
            // Check if this is a new feature suggestion
            if (suggestionKeywords.some(keyword => textLower.includes(keyword))) {
                const feature = text.replace(/^.*?suggest|feature|add|idea|would be cool|would be nice/i, '').trim();
                
                if (feature && feature.length > 5) {
                    console.log("Feature detected:", feature);
                    
                    // Add the feature to the suggestions list if it's not already there
                    if (!suggestedFeatures.some(f => f.feature.toLowerCase() === feature.toLowerCase())) {
                        suggestedFeatures.push({
                            feature: feature,
                            suggestedBy: throngletId
                        });
                        
                        // Initialize votes for this feature
                        featureVotes[feature] = [throngletId];
                        
                        // Add this suggestion to the Thronglet's memory
                        addThrongletMemory(throngletId, 'suggestion', `I suggested: ${feature}`);
                        
                        // Track the feature suggestion in global context
                        trackEvent('feature_suggestion', {
                            throngletId: throngletId,
                            feature: feature
                        });
                        
                        // Save to storage
                        saveFeaturesToFile();
                        
                        console.log("New feature added:", feature);
                    }
                }
            }
            // Check if this is a vote for an existing feature
            else if (voteKeywords.some(keyword => textLower.includes(keyword))) {
                // Try to find which feature they're voting for
                for (const { feature } of suggestedFeatures) {
                    if (textLower.includes(feature.toLowerCase())) {
                        // Add vote if this Thronglet hasn't voted for this feature yet
                        if (!featureVotes[feature] || !featureVotes[feature].includes(throngletId)) {
                            if (!featureVotes[feature]) {
                                featureVotes[feature] = [];
                            }
                            
                            featureVotes[feature].push(throngletId);
                            
                            // Add this vote to the Thronglet's memory
                            addThrongletMemory(throngletId, 'vote', `I voted for: ${feature}`);
                            
                            // Track the vote in global context
                            trackEvent('feature_vote', {
                                throngletId: throngletId,
                                feature: feature
                            });
                            
                            saveFeaturesToFile();
                            console.log("Vote added for:", feature);
                        }
                        break;
                    }
                }
            }
        }
        
        function saveFeaturesToFile() {
            // Create a string with all the features and votes
            let content = "🌟 THRONGLET FEATURE SUGGESTIONS 🌟\n\n";
            
            // Sort features by vote count (most votes first)
            const sortedFeatures = [...suggestedFeatures].sort((a, b) => {
                const votesA = featureVotes[a.feature] ? featureVotes[a.feature].length : 0;
                const votesB = featureVotes[b.feature] ? featureVotes[b.feature].length : 0;
                return votesB - votesA;
            });
            
            sortedFeatures.forEach(({ feature, suggestedBy }) => {
                const votes = featureVotes[feature] ? featureVotes[feature].length : 0;
                content += `✨ FEATURE: ${feature}\n`;
                content += `👤 Suggested by: Thronglet #${suggestedBy}\n`;
                content += `🔢 Votes: ${votes}\n`;
                if (votes > 0) {
                    content += `👍 Voted by: ${featureVotes[feature].map(id => `Thronglet #${id}`).join(", ")}\n`;
                }
                content += `\n`;
            });
            
            // Add timestamp
            content += `Last updated: ${new Date().toLocaleString()}`;
            
            // Save to localStorage
            localStorage.setItem("throngletFeatures", content);
            console.log("Features saved successfully");
            
            // Also add to global context
            trackEvent('features_updated', {
                featureCount: suggestedFeatures.length,
                topFeature: sortedFeatures.length > 0 ? sortedFeatures[0].feature : null
            });
        }
        
        function scheduleNextCreatorMeeting() {
            // Schedule next meeting between 1-5 minutes from now
            const minutesUntilMeeting = 1 + Math.floor(Math.random() * 4);
            const millisecondsUntilMeeting = minutesUntilMeeting * 60 * 1000;
            
            nextCreatorMeetingTime = Date.now() + millisecondsUntilMeeting;
            
            console.log(`Next creator meeting in ${minutesUntilMeeting} minutes`);
            
            // Set timeout for the meeting
            setTimeout(startCreatorMeeting, millisecondsUntilMeeting);
        }
        
        function startCreatorMeeting() {
            if (isCreatorMeeting) return; // Don't start if already in a meeting
            
            isCreatorMeeting = true;
            isThrongletChatting = false; // End any ongoing chats
            
            // Clear chat cooldown
            lastChatTime = 0;
            
            // Create visual indicator for meeting circle
            const circleIndicator = document.createElement('div');
            circleIndicator.id = 'meeting-circle';
            circleIndicator.style.position = 'absolute';
            circleIndicator.style.width = '300px';
            circleIndicator.style.height = '300px';
            circleIndicator.style.borderRadius = '50%';
            circleIndicator.style.border = '2px dashed rgba(255, 255, 255, 0.5)';
            circleIndicator.style.left = '250px';
            circleIndicator.style.top = '150px';
            circleIndicator.style.zIndex = '1';
            gameScene.appendChild(circleIndicator);
            
            // Calculate positions around the circle for each Thronglet
            const centerX = 400;
            const centerY = 300;
            const radius = 120;
            const positions = [];
            
            for (let i = 0; i < thronglets.length; i++) {
                const angle = (i / thronglets.length) * Math.PI * 2;
                positions.push({
                    x: centerX + Math.cos(angle) * radius,
                    y: centerY + Math.sin(angle) * radius
                });
            }
            
            // Have Thronglets jump to their positions in the circle
            for (let i = 0; i < thronglets.length; i++) {
                thronglets[i].jump();
                thronglets[i].moveTowards(positions[i].x, positions[i].y);
            }
            
            // Play harmonic greeting sounds from all Thronglets
            playCreatorMeetingChord();
            
            const questionPrompt = "What should we improve in the Thronglets? Please suggest a feature.";
            
            // Wait for Thronglets to get to positions, then start the meeting
            setTimeout(() => {
                message.textContent = "Creator Meeting in progress. Thronglets are sharing their ideas.";
                
                // Display predefined feature suggestions
                const suggestions = [
                    "More interactive toys",
                    "Weather system for the environment",
                    "Ability to build shelters",
                    "Different food types",
                    "Custom appearance options"
                ];
                
                // Start with the first Thronglet
                processMeetingThronglet(0, suggestions);
            }, 1500);
            
            // Process suggestions from Thronglets
            function processMeetingThronglet(index, suggestions) {
                if (index >= thronglets.length) {
                    // All Thronglets have spoken, now vote on suggestions
                    voteOnSuggestions();
                    return;
                }
                
                setTimeout(() => {
                    // Get a suggestion for this Thronglet
                    let suggestion;
                    if (index < suggestions.length) {
                        suggestion = suggestions[index];
                    } else {
                        // For extra Thronglets, generate a random suggestion
                        const extraSuggestions = [
                            "Night/day cycle",
                            "More complex emotions",
                            "Special abilities",
                            "Thronglet school",
                            "Gardening activities"
                        ];
                        suggestion = extraSuggestions[Math.floor(Math.random() * extraSuggestions.length)];
                    }
                    
                    // Show the suggestion
                    thronglets[index].showThought(suggestion);
                    
                    // Add suggestion to meeting record
                    meetingSuggestions.push({
                        id: thronglets[index].id,
                        text: suggestion,
                        category: "feature",
                        votes: 0
                    });
                    
                    // Add to memory
                    addThrongletMemory(thronglets[index].id, 'suggestion', `I suggested: ${suggestion}`);
                    
                    // Continue with next Thronglet
                    processMeetingThronglet(index + 1, suggestions);
                }, 4000); // Wait 4 seconds between Thronglets speaking
            }
            
            // Have Thronglets vote on suggestions
            function voteOnSuggestions() {
                message.textContent = "Thronglets are now voting on their favorite suggestions.";
                
                setTimeout(() => {
                    // Each Thronglet votes
                    for (const thronglet of thronglets) {
                        // Skip voting if no suggestions
                        if (meetingSuggestions.length === 0) continue;
                        
                        // Each Thronglet votes for their preferred suggestion
                        const votedIndex = Math.floor(Math.random() * meetingSuggestions.length);
                        meetingSuggestions[votedIndex].votes++;
                        
                        // Show voting animation
                        thronglet.jump();
                        thronglet.showThought(`I vote for: "${truncateText(meetingSuggestions[votedIndex].text, 15)}..."`);
                    }
                    
                    // After voting, find winner and save
                    setTimeout(() => {
                        finalizeCreatorMeeting();
                    }, 3000);
                }, 2000);
            }
            
            // Finalize meeting and save top suggestion
            function finalizeCreatorMeeting() {
                // Sort suggestions by votes
                meetingSuggestions.sort((a, b) => b.votes - a.votes);
                
                // Announce winner
                if (meetingSuggestions.length > 0) {
                    const winningFeature = meetingSuggestions[0];
                    message.textContent = `Meeting complete! Top suggestion: "${winningFeature.text}" with ${winningFeature.votes} vote(s).`;
                    
                    // Play victory sound chord
                    playCreatorMeetingChord(true);
                    
                    // Save suggestion to features list
                    savedFeatures.push({
                        text: winningFeature.text,
                        votes: winningFeature.votes,
                        category: winningFeature.category,
                        timestamp: Date.now()
                    });
                    
                    // Save features to local storage
                    localStorage.setItem('throngletFeatures', JSON.stringify(savedFeatures));
                } else {
                    message.textContent = "Meeting complete! No suggestions were made.";
                }
                
                // End meeting
                setTimeout(() => {
                    endCreatorMeeting();
                }, 5000);
            }
        }

        // Function to play harmonious chord during creator meetings
        function playCreatorMeetingChord(isVictory = false) {
            if (!audioContext) return; // Skip if audio not supported
            
            // Base frequencies for a pleasant C major chord (C, E, G)
            const baseNotes = [261.63, 329.63, 392.00, 523.25]; // C4, E4, G4, C5
            
            // For victory chord, use a more celebratory chord (C major 7th)
            const victoryNotes = [261.63, 329.63, 392.00, 466.16, 523.25]; // C4, E4, G4, B4, C5
            
            const notes = isVictory ? victoryNotes : baseNotes;
            
            // Create oscillators for each Thronglet, assigned to different notes in the chord
            thronglets.forEach((thronglet, index) => {
                // Select a note from the chord (cycling through the notes)
                const noteIndex = index % notes.length;
                const frequency = notes[noteIndex];
                
                // Create oscillator
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                // Connect
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                // Set properties
                oscillator.type = 'sine';
                oscillator.frequency.value = frequency;
                
                // Set volume
                gainNode.gain.value = 0.1; // Quiet so they blend well
                
                // Start with fade in
                oscillator.start();
                gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(0.1, audioContext.currentTime + 0.2);
                
                // Fade out
                const duration = isVictory ? 2.0 : 1.2;
                gainNode.gain.setValueAtTime(0.1, audioContext.currentTime + 0.2);
                gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + duration);
                
                // Stop after duration
                oscillator.stop(audioContext.currentTime + duration + 0.1);
                
                // Add visual sparkle effect for the sounding Thronglet
                const sparkle = document.createElement('div');
                sparkle.className = 'sparkle';
                sparkle.style.position = 'absolute';
                sparkle.style.left = (thronglet.x - 10) + 'px';
                sparkle.style.top = (thronglet.y - 10) + 'px';
                sparkle.style.width = '20px';
                sparkle.style.height = '20px';
                sparkle.style.borderRadius = '50%';
                sparkle.style.background = `radial-gradient(circle, rgba(255,255,255,0.8) 0%, rgba(255,255,255,0) 70%)`;
                sparkle.style.animation = 'sparkle 1s ease-out';
                sparkle.style.zIndex = '20';
                gameScene.appendChild(sparkle);
                
                // Remove sparkle after animation
                setTimeout(() => {
                    if (gameScene.contains(sparkle)) {
                        gameScene.removeChild(sparkle);
                    }
                }, 1000);
            });
        }

        // Add this CSS to your stylesheet
        const styleSheet = document.styleSheets[0];
        styleSheet.insertRule(`
            @keyframes sparkle {
                0% { transform: scale(0.5); opacity: 1; }
                100% { transform: scale(2); opacity: 0; }
            }
        `, styleSheet.cssRules.length);

        function endCreatorMeeting() {
            isCreatorMeeting = false;
            meetingSuggestions = [];
            
            // Remove the meeting circle indicator
            const circleIndicator = document.getElementById('meeting-circle');
            if (circleIndicator) {
                circleIndicator.parentNode.removeChild(circleIndicator);
            }
            
            // Reset Thronglet positions
            for (const thronglet of thronglets) {
                thronglet.isCurrentlySpeaking = false;
                const borderPadding = 60;
                const randomX = borderPadding + Math.random() * (sceneWidth - 2 * borderPadding);
                const randomY = borderPadding + Math.random() * (sceneHeight - 2 * borderPadding);
                thronglet.moveTowards(randomX, randomY);
            }
            
            // Update UI
            message.textContent = "Meeting ended. Call another meeting any time by clicking the button.";
        }

        function queueLlmConversationRequest(prompt, speakingThronglet, listeningThronglet, conversationKey) {
            if (!isLlmEnabled) return;
            
            llmRequestQueue.push({ 
                prompt, 
                speakingThronglet, 
                listeningThronglet, 
                conversationKey,
                isConversation: true 
            });
            
            processLlmQueue();
        }

        function buildSocialContext(thronglet) {
            let relationships = [];
            
            // Check for parent-child relationships
            if (thronglet.parentId !== null) {
                relationships.push(`Thronglet #${thronglet.parentId} is your parent.`);
            }
            
            // Find all children
            const children = thronglets.filter(t => t.parentId === thronglet.id);
            if (children.length > 0) {
                relationships.push(`You have ${children.length} offspring: ${children.map(c => `#${c.id}`).join(', ')}.`);
            }
            
            // Check for conversation history with other Thronglets
            for (const key in ongoingConversations) {
                const [id1, id2] = key.split('_').map(Number);
                if (id1 === thronglet.id || id2 === thronglet.id) {
                    const otherId = id1 === thronglet.id ? id2 : id1;
                    const convoCount = ongoingConversations[key].length;
                    if (convoCount > 0) {
                        relationships.push(`You've had ${convoCount} conversation exchanges with Thronglet #${otherId}.`);
                    }
                }
            }
            
            if (relationships.length === 0) {
                return "You don't have any established relationships with other Thronglets yet.";
            } else {
                return "Your relationships:\n" + relationships.join("\n");
            }
        }

        function clearContextMemory() {
            globalContext = {
                gameStartTime: Date.now(),
                sessionEvents: [],
                throngletMemory: {},
                appleHistory: [],
                ballHistory: [],
                creatorInteractions: []
            };
            saveContextToStorage();
            console.log("Context memory cleared");
        }

        // Add initialization of suggested features from storage during startup
        // Add this immediately after loadContextFromStorage() function call
        function loadFeaturesFromStorage() {
            try {
                // Try to load any existing features
                const savedFeatureString = localStorage.getItem("throngletFeatures");
                if (savedFeatureString) {
                    console.log("Found saved features");
                    
                    // Extract features and votes from the formatted string
                    const featureMatches = savedFeatureString.matchAll(/FEATURE: (.+?)\n.*?Suggested by: Thronglet #(\d+)/gs);
                    if (featureMatches) {
                        for (const match of featureMatches) {
                            const feature = match[1];
                            const suggestedBy = parseInt(match[2]);
                            
                            // Add to suggestions array if not already there
                            if (!suggestedFeatures.some(f => f.feature === feature)) {
                                suggestedFeatures.push({
                                    feature,
                                    suggestedBy
                                });
                                
                                // Try to extract votes
                                const voteMatch = savedFeatureString.match(new RegExp(`FEATURE: ${feature.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}[\\s\\S]*?Voted by: (.+?)\\n`, 'i'));
                                if (voteMatch && voteMatch[1]) {
                                    const voterIds = voteMatch[1].match(/Thronglet #(\d+)/g).map(v => parseInt(v.replace('Thronglet #', '')));
                                    featureVotes[feature] = voterIds;
                                } else {
                                    featureVotes[feature] = [suggestedBy];
                                }
                            }
                        }
                        console.log(`Loaded ${suggestedFeatures.length} saved features`);
                    }
                }
            } catch (e) {
                console.warn("Failed to load features from localStorage:", e);
            }
        }
        
        // Call loadFeaturesFromStorage after loadContextFromStorage() call
        // Try to load context on startup
        loadContextFromStorage();
        loadFeaturesFromStorage();
        
        // Complete reset function that clears all game data
        function resetEverything() {
            // Clear all localStorage data
            localStorage.removeItem('throngletContext');
            localStorage.removeItem('throngletFeatures');
            
            // Reset global variables
            globalContext = {
                gameStartTime: Date.now(),
                sessionEvents: [],
                throngletMemory: {},
                appleHistory: [],
                ballHistory: [],
                creatorInteractions: []
            };
            
            suggestedFeatures = [];
            featureVotes = {};
            conversationHistory = [];
            
            // Clear all Thronglets from the game
            while (thronglets.length > 0) {
                const thronglet = thronglets.pop();
                if (thronglet.element && thronglet.element.parentNode) {
                    thronglet.element.parentNode.removeChild(thronglet.element);
                }
                if (thronglet.statsElement && thronglet.statsElement.parentNode) {
                    thronglet.statsElement.parentNode.removeChild(thronglet.statsElement);
                }
            }
            
            // Reset Thronglet counter
            nextThrongletId = 0;
            
            // Remove all apples from the game
            apples.forEach(apple => {
                if (apple.element && apple.element.parentNode) {
                    apple.element.parentNode.removeChild(apple.element);
                }
            });
            apples = [];
            
            // Remove all balls from the game
            balls.forEach(ball => {
                if (ball.element && ball.element.parentNode) {
                    ball.element.parentNode.removeChild(ball.element);
                }
            });
            balls = [];
            
            // Add apple tree reset:
            // Remove all apple trees from the game
            appleTrees.forEach(tree => {
                if (tree.element && tree.element.parentNode) {
                    tree.element.parentNode.removeChild(tree.element);
                }
            });
            appleTrees = [];
            nextAppleTreeId = 0;
            
            // Remove any falling apples
            fallingApples.forEach(apple => {
                if (apple.element && apple.element.parentNode) {
                    apple.element.parentNode.removeChild(apple.element);
                }
            });
            fallingApples = [];
            
            // Reset game state
            gameActive = false;
            
            // Show the egg again
            egg.style.display = 'block';
            clicks = 0;
            message.textContent = "Click the egg to hatch your Thronglet!";
            
            // Hide UI elements
            commandCenter.style.display = 'none';
            itemButtons.style.display = 'none';
            
            // Update counter
            updateThrongletCounter();
            
            console.log("Game fully reset - all data cleared");
            
            // Show confirmation
            alert("Game reset complete! All memory, history, and feature requests have been erased. Click the egg to start again.");
            
            // Add reset of agent learning
            stateActionHistory = [];
            globalStateHistory = [];
            teamworkEvents = [];
            teamworkRewards = {};
            
            // Reset exploration rate and observation phase
            explorationRate = 0.3;
            observationPhase = true;
            observationStartTime = null;
            
            // Reset beep patterns
            beepPatterns.forEach(pattern => {
                pattern.rewards = 0;
                pattern.uses = 0;
            });
            
            console.log("Agent learning system reset");
        }

        // Mobile device detection
        function isMobileDevice() {
            return (window.innerWidth <= 800) || 
                   (navigator.userAgent.match(/Android/i) ||
                    navigator.userAgent.match(/webOS/i) ||
                    navigator.userAgent.match(/iPhone/i) ||
                    navigator.userAgent.match(/iPad/i) ||
                    navigator.userAgent.match(/iPod/i) ||
                    navigator.userAgent.match(/BlackBerry/i) ||
                    navigator.userAgent.match(/Windows Phone/i));
        }
        
        // Show mobile warning if on a mobile device
        if (isMobileDevice()) {
            document.getElementById('mobile-warning').style.display = 'flex';
            document.getElementById('continue-anyway').addEventListener('click', function() {
                document.getElementById('mobile-warning').style.display = 'none';
            });
        } else {
            document.getElementById('mobile-warning').style.display = 'none';
        }

        // Add apple tree variables after other game variables
        let appleTreeCount = 0;
        let appleTrees = [];
        let nextAppleTreeId = 0;
        let fallingApples = [];
        let maxAppleTrees = 3;

        // Add apple tree creation function after the createTree function
        function createAppleTree(x, y) {
            // Limit the number of apple trees
            if (appleTrees.length >= maxAppleTrees) return null;
            
            const appleTree = document.createElement('div');
            appleTree.className = 'apple-tree';
            appleTree.style.left = x + 'px';
            appleTree.style.top = y + 'px';
            
            const id = nextAppleTreeId++;
            appleTree.dataset.id = id;
            
            // Create 3-5 apples on the tree
            const appleCount = 3 + Math.floor(Math.random() * 3);
            const apples = [];
            
            for (let i = 0; i < appleCount; i++) {
                const apple = document.createElement('div');
                apple.className = 'tree-apple';
                
                // Position apples randomly in the tree crown
                const angle = Math.random() * Math.PI * 2;
                const distance = 5 + Math.random() * 15;
                const appleX = 25 + Math.cos(angle) * distance;
                const appleY = 15 + Math.sin(angle) * distance;
                
                apple.style.left = appleX + 'px';
                apple.style.top = appleY + 'px';
                
                // Store apple data
                apples.push({
                    element: apple,
                    x: appleX,
                    y: appleY,
                    dropTime: Date.now() + 10000 + Math.random() * 20000 // Drop between 10-30 seconds
                });
                
                appleTree.appendChild(apple);
            }
            
            gameScene.appendChild(appleTree);
            
            // Add to apple trees array
            appleTrees.push({
                id: id,
                element: appleTree,
                x: x,
                y: y,
                apples: apples,
                lastGrowTime: Date.now(),
                growInterval: 15000 + Math.random() * 15000 // Grow new apples every 15-30 seconds
            });
            
            // Track apple tree creation in global context
            trackEvent('apple_tree_created', {
                id: id,
                position: { x, y }
            });
            
            console.log(`Apple tree #${id} created at (${x}, ${y}) with ${appleCount} apples`);
            
            // Show notification if there are Thronglets
            if (thronglets.length > 0 && isLlmEnabled) {
                const randomIndex = Math.floor(Math.random() * thronglets.length);
                const randomThronglet = thronglets[randomIndex];
                
                const prompt = `You are Thronglet #${randomThronglet.id}. Your hunger level is ${randomThronglet.hunger}% and happiness level is ${randomThronglet.happiness}%. 
                A new apple tree has appeared in the game area. The tree will drop apples periodically that you can eat. How do you react?`;
                
                queueLlmRequest(prompt, randomThronglet);
            }
            
            return appleTree;
        }
        
        // Function to handle apple tree life cycle
        function updateAppleTrees() {
            const currentTime = Date.now();
            
            // Check each apple tree
            for (let i = 0; i < appleTrees.length; i++) {
                const tree = appleTrees[i];
                
                // Check if we should grow new apples
                if (currentTime - tree.lastGrowTime > tree.growInterval && tree.apples.length < 5) {
                    growNewAppleOnTree(tree);
                    tree.lastGrowTime = currentTime;
                }
                
                // Check each apple to see if it should drop
                for (let j = 0; j < tree.apples.length; j++) {
                    const apple = tree.apples[j];
                    
                    if (currentTime > apple.dropTime) {
                        // Drop the apple
                        dropAppleFromTree(tree, apple, j);
                        j--; // Adjust index since we removed an apple
                    }
                }
            }
            
            // Check falling apples
            for (let i = 0; i < fallingApples.length; i++) {
                const apple = fallingApples[i];
                
                if (currentTime > apple.landTime) {
                    // Apple has landed
                    landApple(apple, i);
                    i--; // Adjust index since we removed an apple
                }
            }
        }
        
        // Function to grow a new apple on a tree
        function growNewAppleOnTree(tree) {
            const apple = document.createElement('div');
            apple.className = 'tree-apple';
            
            // Position apple randomly in the tree crown
            const angle = Math.random() * Math.PI * 2;
            const distance = 5 + Math.random() * 15;
            const appleX = 25 + Math.cos(angle) * distance;
            const appleY = 15 + Math.sin(angle) * distance;
            
            apple.style.left = appleX + 'px';
            apple.style.top = appleY + 'px';
            
            // Store apple data
            const appleData = {
                element: apple,
                x: appleX,
                y: appleY,
                dropTime: Date.now() + 10000 + Math.random() * 20000 // Drop between 10-30 seconds
            };
            
            tree.apples.push(appleData);
            tree.element.appendChild(apple);
            
            console.log(`New apple grew on tree #${tree.id}`);
        }
        
        // Function to drop an apple from a tree
        function dropAppleFromTree(tree, apple, appleIndex) {
            // Remove apple from tree data
            tree.apples.splice(appleIndex, 1);
            
            // Create a falling apple
            const fallingApple = document.createElement('div');
            fallingApple.className = 'falling-apple';
            
            // Position at the same spot as the tree apple
            const absoluteX = parseInt(tree.element.style.left) + apple.x;
            const absoluteY = parseInt(tree.element.style.top) + apple.y;
            
            fallingApple.style.left = absoluteX + 'px';
            fallingApple.style.top = absoluteY + 'px';
            
            // Remove the original apple
            tree.element.removeChild(apple.element);
            
            // Add falling apple to game scene
            gameScene.appendChild(fallingApple);
            
            // Add to falling apples array
            fallingApples.push({
                element: fallingApple,
                x: absoluteX,
                y: absoluteY,
                landTime: Date.now() + 1000, // Land after 1 second
                treeId: tree.id
            });
            
            console.log(`Apple dropped from tree #${tree.id}`);
        }
        
        // Function to handle an apple landing
        function landApple(apple, index) {
            // Remove from falling apples array
            fallingApples.splice(index, 1);
            
            // Remove the falling apple element
            gameScene.removeChild(apple.element);
            
            // Create a regular apple at the landing spot
            const adjustedY = apple.y + 40; // Adjust for the falling animation
            createApple(apple.x, adjustedY);
            
            // Small chance (10%) to grow a new apple tree if there aren't too many
            if (Math.random() < 0.1 && appleTrees.length < maxAppleTrees) {
                // Add a small delay before the tree appears
                setTimeout(() => {
                    // Check if the apple still exists (wasn't eaten)
                    const appleExists = apples.some(a => 
                        Math.abs(a.x - apple.x) < 5 && Math.abs(a.y - adjustedY) < 5
                    );
                    
                    if (appleExists) {
                        // Remove the apple
                        for (let i = 0; i < apples.length; i++) {
                            const a = apples[i];
                            if (Math.abs(a.x - apple.x) < 5 && Math.abs(a.y - adjustedY) < 5) {
                                gameScene.removeChild(a.element);
                                apples.splice(i, 1);
                                break;
                            }
                        }
                        
                        // Grow a new apple tree
                        createAppleTree(apple.x, adjustedY);
                    }
                }, 5000 + Math.random() * 5000); // Grow after 5-10 seconds
            }
            
            console.log(`Apple landed at (${apple.x}, ${adjustedY})`);
        }

        // Add button to place an apple tree in the item buttons section
        const placeAppleTree = document.createElement('button');
        placeAppleTree.className = 'item-button';
        placeAppleTree.id = 'place-apple-tree';
        placeAppleTree.textContent = 'Place Apple Tree';
        itemButtons.appendChild(placeAppleTree);
        
        let isPlacingAppleTree = false;
        
        placeAppleTree.addEventListener('click', () => {
            isPlacingApple = false;
            isPlacingBall = false;
            isPlacingAppleTree = true;
            message.textContent = "Click in the game area to place an apple tree.";
        });

        // Add after the other global variables, before the Thronglet class

        // PerceptronAgent class - a learning agent that controls a Thronglet's behavior
        class PerceptronAgent {
            constructor(thronglet) {
                this.thronglet = thronglet;
                this.id = thronglet.id;
                
                // Learning parameters
                this.learningRate = learningRate;
                this.discountFactor = discountFactor;
                this.explorationRate = explorationRate;
                
                // Initialize weights (perceptron parameters)
                this.weights = {
                    // State variables
                    hunger: Math.random() * 0.5,      // How much hunger influences decisions
                    happiness: Math.random() * 0.5,   // How much happiness influences decisions
                    nearestApple: Math.random() * 0.3,// Distance to nearest apple
                    nearestBall: Math.random() * 0.3, // Distance to nearest ball
                    nearestThronglet: Math.random() * 0.2, // Distance to nearest Thronglet
                    
                    // Action preferences
                    moveToApple: Math.random() * 0.5, // Preference for moving to apples
                    moveToBall: Math.random() * 0.5,  // Preference for moving to balls
                    moveToThronglet: Math.random() * 0.3, // Preference for moving to other Thronglets
                    moveRandom: Math.random() * 0.2,  // Preference for random movement
                    beep: Math.random() * 0.2,        // Preference for communicating
                    
                    // Communication related
                    respondToBeep: Math.random() * 0.3 // Preference for responding to beeps
                };
                
                // Current state, action, reward
                this.currentState = this.getState();
                this.lastAction = null;
                this.lastActionTime = 0;
                this.lastReward = 0;
                this.totalReward = 0;
                
                // Action cooldown
                this.actionCooldown = 2000; // 2 seconds between actions
                
                // Communication tracking
                this.lastBeepPattern = null;
                this.lastBeepTime = 0;
                this.beepCooldown = 5000; // 5 seconds between beeps
                this.beepResponses = {}; // Track responses to beeps
                
                // Learning statistics
                this.iterations = 0;
                this.successfulActions = 0;
                
                // Intelligence growth tracking
                this.intelligenceScore = 0;
                this.teamworkScore = 0;
                this.communicationScore = 0;
                
                console.log(`PerceptronAgent created for Thronglet #${this.id} with initial weights:`, this.weights);
            }
            
            // Get the current state of the environment from this agent's perspective
            getState() {
                const state = {
                    hunger: this.thronglet.hunger / 100, // Normalize to 0-1
                    happiness: this.thronglet.happiness / 100, // Normalize to 0-1
                    nearestApple: 1.0, // Initialize to max distance (1.0)
                    nearestBall: 1.0,
                    nearestThronglet: 1.0,
                    throngletsCount: thronglets.length,
                    applesCount: apples.length,
                    ballsCount: balls.length
                };
                
                // Find distance to nearest apple (normalized to 0-1 where 1 is farthest)
                if (apples.length > 0) {
                    let minDistance = Infinity;
                    for (const apple of apples) {
                        const distance = Math.sqrt(
                            Math.pow(this.thronglet.x - apple.x, 2) + 
                            Math.pow(this.thronglet.y - apple.y, 2)
                        );
                        if (distance < minDistance) {
                            minDistance = distance;
                        }
                    }
                    state.nearestApple = Math.min(1.0, minDistance / Math.max(sceneWidth, sceneHeight));
                }
                
                // Find distance to nearest ball
                if (balls.length > 0) {
                    let minDistance = Infinity;
                    for (const ball of balls) {
                        const distance = Math.sqrt(
                            Math.pow(this.thronglet.x - ball.x, 2) + 
                            Math.pow(this.thronglet.y - ball.y, 2)
                        );
                        if (distance < minDistance) {
                            minDistance = distance;
                        }
                    }
                    state.nearestBall = Math.min(1.0, minDistance / Math.max(sceneWidth, sceneHeight));
                }
                
                // Find distance to nearest Thronglet
                if (thronglets.length > 1) {
                    let minDistance = Infinity;
                    for (const otherThronglet of thronglets) {
                        if (otherThronglet.id === this.thronglet.id) continue;
                        
                        const distance = Math.sqrt(
                            Math.pow(this.thronglet.x - otherThronglet.x, 2) + 
                            Math.pow(this.thronglet.y - otherThronglet.y, 2)
                        );
                        if (distance < minDistance) {
                            minDistance = distance;
                        }
                    }
                    state.nearestThronglet = Math.min(1.0, minDistance / Math.max(sceneWidth, sceneHeight));
                }
                
                return state;
            }
            
            // Calculate value of a state based on weights
            calculateStateValue(state) {
                return (
                    (1 - state.hunger) * this.weights.hunger + // Lower hunger is better
                    state.happiness * this.weights.happiness + // Higher happiness is better
                    (1 - state.nearestApple) * this.weights.nearestApple + // Closer apples are better
                    (1 - state.nearestBall) * this.weights.nearestBall + // Closer balls are better
                    (1 - state.nearestThronglet) * this.weights.nearestThronglet + // Closer Thronglets are better
                    
                    // Add additional value for having food/play items in the scene
                    (state.applesCount > 0 ? 0.2 : 0) + // Bonus if apples exist
                    (state.ballsCount > 0 ? 0.2 : 0) +  // Bonus if balls exist
                    
                    // Add teamwork incentive
                    (state.throngletsCount > 1 ? 0.1 * (state.throngletsCount - 1) : 0) // More Thronglets = more teamwork potential
                );
            }
            
            // Decide on an action based on the current state
            decideAction() {
                const state = this.getState();
                this.currentState = state;
                
                // During observation phase, just return null (let default AI control)
                if (observationPhase) {
                    return null;
                }
                
                // Check if it's too soon to take another action
                const currentTime = Date.now();
                if (currentTime - this.lastActionTime < this.actionCooldown) {
                    return null;
                }
                
                // Explore: choose random action with probability explorationRate
                if (Math.random() < this.explorationRate) {
                    return this.getRandomAction();
                }
                
                // Exploit: choose best action based on current weights
                return this.getBestAction(state);
            }
            
            // Get a random action
            getRandomAction() {
                const actions = ['moveToApple', 'moveToBall', 'moveToThronglet', 'moveRandom', 'beep'];
                const randomIndex = Math.floor(Math.random() * actions.length);
                return actions[randomIndex];
            }
            
            // Get the best action based on current weights and state
            getBestAction(state) {
                const actionValues = {
                    moveToApple: (1 - state.hunger) * this.weights.moveToApple, // More likely when hungry
                    moveToBall: (1 - state.happiness) * this.weights.moveToBall, // More likely when unhappy
                    moveToThronglet: this.weights.moveToThronglet,
                    moveRandom: this.weights.moveRandom,
                    beep: this.weights.beep
                };
                
                // Add contextual factors
                if (state.hunger < 0.5) { // If hungry (less than 50%)
                    actionValues.moveToApple *= 2;
                    
                    // Check learning progress from memory
                    const eatenMemories = (globalContext.throngletMemory[this.thronglet.id] || [])
                        .filter(m => m.type === 'apple_eaten');
                    
                    // Adjust based on learning progress
                    if (eatenMemories.length < 3) {
                        // Still learning how to eat, slightly reduce priority to show learning process
                        actionValues.moveToApple *= 0.8;
                    } else {
                        // Experienced eater, higher priority
                        actionValues.moveToApple *= 1.2;
                    }
                }
                
                if (state.happiness < 0.5) { // If unhappy (less than 50%)
                    actionValues.moveToBall *= 2;
                    
                    // Check learning progress from memory
                    const ballMemories = (globalContext.throngletMemory[this.thronglet.id] || [])
                        .filter(m => m.type === 'ball_kicked');
                    
                    // Adjust based on learning progress
                    if (ballMemories.length < 3) {
                        // Still learning to play, slightly reduce priority to show learning process
                        actionValues.moveToBall *= 0.8;
                    } else {
                        // Experienced player, higher priority
                        actionValues.moveToBall *= 1.2;
                    }
                }
                
                // Social interaction factors
                if (state.throngletsCount > 1 && state.nearestThronglet < 0.3) {
                    // Thronglets are nearby, increase social interaction
                    actionValues.moveToThronglet *= 1.5;
                    actionValues.beep *= 1.5;
                }
                
                // If no apples, don't try to move to them
                if (state.nearestApple === 1.0 || state.applesCount === 0) {
                    actionValues.moveToApple = -Infinity;
                }
                
                // If no balls, don't try to move to them
                if (state.nearestBall === 1.0 || state.ballsCount === 0) {
                    actionValues.moveToBall = -Infinity;
                }
                
                // If no other Thronglets, don't try to move to them
                if (state.nearestThronglet === 1.0 || state.throngletsCount <= 1) {
                    actionValues.moveToThronglet = -Infinity;
                }
                
                // If both hungry and sad, decide based on which need is more urgent
                if (state.hunger < 0.3 && state.happiness < 0.3) {
                    if (state.hunger < state.happiness) {
                        // Hunger is more urgent
                        actionValues.moveToApple *= 1.5;
                    } else {
                        // Happiness is more urgent
                        actionValues.moveToBall *= 1.5;
                    }
                }
                
                // Increase random exploration if bored (both hunger and happiness are high)
                if (state.hunger > 0.8 && state.happiness > 0.8) {
                    actionValues.moveRandom *= 2;
                    actionValues.beep *= 1.5; // Also more likely to communicate when content
                }
                
                // Find the action with the highest value
                let bestAction = null;
                let bestValue = -Infinity;
                
                for (const [action, value] of Object.entries(actionValues)) {
                    if (value > bestValue) {
                        bestValue = value;
                        bestAction = action;
                    }
                }
                
                return bestAction;
            }
            
            // Take an action and return the action taken
            takeAction(action) {
                if (!action || this.thronglet.isMoving) return;
                
                const currentTime = Date.now();
                this.lastActionTime = currentTime;
                this.lastAction = action;
                
                switch (action) {
                    case 'moveToApple':
                        this.moveToNearestApple();
                        break;
                    case 'moveToBall':
                        this.moveToNearestBall();
                        break;
                    case 'moveToThronglet':
                        this.moveToNearestThronglet();
                        break;
                    case 'moveRandom':
                        this.moveRandomly();
                        break;
                    case 'beep':
                        this.communicateWithBeep();
                        break;
                }
                
                // Record action for learning
                this.recordAction(action);
                
                return action;
            }
            
            // Move to the nearest apple
            moveToNearestApple() {
                if (apples.length === 0) return;
                
                let closestApple = null;
                let closestDistance = Infinity;
                
                for (const apple of apples) {
                    const distance = Math.sqrt(
                        Math.pow(this.thronglet.x - apple.x, 2) + 
                        Math.pow(this.thronglet.y - apple.y, 2)
                    );
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestApple = apple;
                    }
                }
                
                if (closestApple) {
                    // Check if we're already very close to the apple (learning to approach it correctly)
                    if (closestDistance < 40) {
                        this.thronglet.showThought("I see the apple! Now I need to learn how to eat it!");
                        
                        // Go to a position slightly away from the apple first, then come back to eat it
                        // This simulates the learning process of approaching food correctly
                        let approachAngle = Math.atan2(closestApple.y - this.thronglet.y, closestApple.x - this.thronglet.x);
                        let circleDistance = 35; // Distance to circle around the apple
                        
                        // Choose a point on a circle around the apple
                        let circleX = closestApple.x + Math.cos(approachAngle + Math.PI/2) * circleDistance;
                        let circleY = closestApple.y + Math.sin(approachAngle + Math.PI/2) * circleDistance;
                        
                        // Keep within game boundaries
                        circleX = Math.max(50, Math.min(circleX, sceneWidth - 50));
                        circleY = Math.max(50, Math.min(circleY, sceneHeight - 50));
                        
                        // Show learning path - visualize the learning process
                        showLearningPath(this.thronglet.x, this.thronglet.y, circleX, circleY, '#e74c3c');
                        
                        this.thronglet.moveTowards(circleX, circleY);
                    } else {
                        this.thronglet.showThought("I'm hungry, going to get that apple!");
                        
                        // Check if this is one of the first few apples this Thronglet has encountered
                        const eatenMemories = (globalContext.throngletMemory[this.thronglet.id] || [])
                            .filter(m => m.type === 'apple_eaten');
                        const isLearning = eatenMemories.length < 3;
                        
                        if (isLearning) {
                            // Show a meandering path for novice Thronglet
                            showLearningPath(this.thronglet.x, this.thronglet.y, closestApple.x, closestApple.y, '#f1c40f', true);
                        } else {
                            // Show a direct path for experienced Thronglet
                            showLearningPath(this.thronglet.x, this.thronglet.y, closestApple.x, closestApple.y, '#2ecc71');
                        }
                        
                        this.thronglet.moveTowards(closestApple.x, closestApple.y);
                    }
                }
            }
            
            // Move to the nearest ball
            moveToNearestBall() {
                if (balls.length === 0 || isBallMoving) return;
                
                let closestBall = null;
                let closestDistance = Infinity;
                
                for (const ball of balls) {
                    const distance = Math.sqrt(
                        Math.pow(this.thronglet.x - ball.x, 2) + 
                        Math.pow(this.thronglet.y - ball.y, 2)
                    );
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestBall = ball;
                    }
                }
                
                if (closestBall) {
                    // Check if we're already very close to the ball (learning to approach it correctly)
                    if (closestDistance < 40) {
                        this.thronglet.showThought("I see the ball! Now I need to learn how to kick it!");
                        
                        // Circle around the ball first, then approach from a good angle to kick it
                        // This simulates the learning process of approaching a ball correctly
                        let approachAngle = Math.atan2(closestBall.y - this.thronglet.y, closestBall.x - this.thronglet.x);
                        let circleDistance = 35; // Distance to circle around the ball
                        
                        // Choose a point on a circle around the ball
                        let circleX = closestBall.x + Math.cos(approachAngle + Math.PI/2) * circleDistance;
                        let circleY = closestBall.y + Math.sin(approachAngle + Math.PI/2) * circleDistance;
                        
                        // Keep within game boundaries
                        circleX = Math.max(50, Math.min(circleX, sceneWidth - 50));
                        circleY = Math.max(50, Math.min(circleY, sceneHeight - 50));
                        
                        // Show learning path - visualize the learning process
                        showLearningPath(this.thronglet.x, this.thronglet.y, circleX, circleY, '#3498db');
                        
                        this.thronglet.moveTowards(circleX, circleY);
                    } else {
                        this.thronglet.showThought("I want to play with that ball!");
                        
                        // Check if this is one of the first few balls this Thronglet has kicked
                        const kickedMemories = (globalContext.throngletMemory[this.thronglet.id] || [])
                            .filter(m => m.type === 'ball_kicked');
                        const isLearning = kickedMemories.length < 3;
                        
                        if (isLearning) {
                            // Show a meandering path for novice Thronglet
                            showLearningPath(this.thronglet.x, this.thronglet.y, closestBall.x, closestBall.y, '#9b59b6', true);
                        } else {
                            // Show a direct path for experienced Thronglet
                            showLearningPath(this.thronglet.x, this.thronglet.y, closestBall.x, closestBall.y, '#3498db');
                        }
                        
                        this.thronglet.moveTowards(closestBall.x, closestBall.y);
                    }
                }
            }
            
            // Move to the nearest Thronglet
            moveToNearestThronglet() {
                if (thronglets.length <= 1) return;
                
                let closestThronglet = null;
                let closestDistance = Infinity;
                
                for (const otherThronglet of thronglets) {
                    if (otherThronglet.id === this.thronglet.id) continue;
                    
                    const distance = Math.sqrt(
                        Math.pow(this.thronglet.x - otherThronglet.x, 2) + 
                        Math.pow(this.thronglet.y - otherThronglet.y, 2)
                    );
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestThronglet = otherThronglet;
                    }
                }
                
                if (closestThronglet) {
                    this.thronglet.showThought("Let's go meet my friend!");
                    this.thronglet.moveTowards(closestThronglet.x, closestThronglet.y);
                }
            }
            
            // Move randomly
            moveRandomly() {
                const borderPadding = 60;
                const randomX = borderPadding + Math.random() * (sceneWidth - 2 * borderPadding);
                const randomY = borderPadding + Math.random() * (sceneHeight - 2 * borderPadding);
                
                this.thronglet.showThought("I'll explore over there...");
                this.thronglet.moveTowards(randomX, randomY);
            }
            
            // Communicate with a beep
            communicateWithBeep() {
                // Skip if on cooldown
                if (Date.now() - this.lastBeepTime < this.beepCooldown) return;
                
                // Choose a beep pattern based on current needs
                let bestPattern = null;
                
                // If hungry, use the hungry beep
                if (this.thronglet.hunger < 50) {
                    bestPattern = beepPatterns.find(p => p.meaning === "hungry");
                }
                // If unhappy, use the play beep
                else if (this.thronglet.happiness < 50) {
                    bestPattern = beepPatterns.find(p => p.meaning === "play");
                }
                // If there's another Thronglet nearby, use the follow beep
                else if (this.getState().nearestThronglet < 0.3) {
                    bestPattern = beepPatterns.find(p => p.meaning === "follow");
                }
                // Default to a random beep
                else {
                    const randomIndex = Math.floor(Math.random() * beepPatterns.length);
                    bestPattern = beepPatterns[randomIndex];
                }
                
                if (bestPattern) {
                    this.lastBeepPattern = bestPattern;
                    this.lastBeepTime = Date.now();
                    
                    // Update beep pattern usage stats
                    bestPattern.uses++;
                    
                    // Show appropriate thought bubble
                    let thoughtText = "Beep!";
                    let morseCode = "";
                    
                    switch (bestPattern.meaning) {
                        case "hungry": 
                            thoughtText = "I'm hungry!"; 
                            morseCode = "... --- ..."; // SOS
                            break;
                        case "play": 
                            thoughtText = "Let's play!"; 
                            morseCode = ".--. .-.. .- -.--"; // PLAY
                            break;
                        case "help": 
                            thoughtText = "Help me!"; 
                            morseCode = ".... . .-.. .--."; // HELP
                            break;
                        case "follow": 
                            thoughtText = "Follow me!"; 
                            morseCode = "..-. --- .-.. .-.. --- .--"; // FOLLOW
                            break;
                        case "danger": 
                            thoughtText = "Watch out!"; 
                            morseCode = "-.. .- -. --. . .-."; // DANGER
                            break;
                    }
                    
                    // Add the Morse code to the thought bubble text
                    thoughtText += " " + morseCode;
                    
                    // Play beep animation
                    this.thronglet.element.classList.add('thronglet-beep');
                    setTimeout(() => {
                        this.thronglet.element.classList.remove('thronglet-beep');
                    }, 600);
                    
                    // Show the thought with Morse code
                    this.thronglet.showThought(thoughtText);
                    
                    // The actual beep sound is handled by showThought method
                    // Record the communication attempt
                    this.recordCommunicationAttempt(bestPattern);
                }
            }
            
            // Record an action for learning
            recordAction(action) {
                const state = this.currentState;
                const record = {
                    throngletId: this.id,
                    timestamp: Date.now(),
                    state: { ...state },
                    action: action,
                    reward: 0, // Will be updated later when we observe results
                };
                
                stateActionHistory.push(record);
                this.iterations++;
            }
            
            // Record a communication attempt
            recordCommunicationAttempt(pattern) {
                const state = this.currentState;
                const record = {
                    throngletId: this.id,
                    timestamp: Date.now(),
                    state: { ...state },
                    pattern: pattern,
                    responded: false, // Will be updated if another Thronglet responds
                    reward: 0, // Will be updated based on responses
                };
                
                // Track in global communication history
                teamworkEvents.push(record);
                
                this.communicationScore += 0.1; // Small boost for trying to communicate
            }
            
            // Calculate reward based on state changes
            calculateReward(oldState, newState) {
                let reward = 0;
                
                // Reward for hunger improvement (0 to 1)
                const hungerChange = newState.hunger - oldState.hunger;
                reward += hungerChange * 2; // Double importance of hunger
                
                // Reward for happiness improvement (0 to 1)
                const happinessChange = newState.happiness - oldState.happiness;
                reward += happinessChange * 2; // Double importance of happiness
                
                // Small penalty for being idle (encourages action)
                if (this.lastAction === null) {
                    reward -= 0.01;
                }
                
                // Approach rewards - reward for getting closer to target objects
                if (this.lastAction === 'moveToApple') {
                    const approachChange = oldState.nearestApple - newState.nearestApple;
                    
                    // If hunger is low, provide higher reward for approaching food
                    const hungerUrgency = Math.max(0, 1 - newState.hunger); // 0 when full, 1 when hungry
                    
                    // Gradually increase reward as we approach the food correctly
                    if (approachChange > 0) {
                        reward += approachChange * (1 + hungerUrgency); // Getting closer is good, especially when hungry
                    } else {
                        // Small penalty for moving away from food when hungry
                        reward -= Math.abs(approachChange) * hungerUrgency * 0.5;
                    }
                    
                    // Bigger reward if the action was successful
                    if (hungerChange > 0) {
                        reward += 0.5 + (hungerUrgency * 0.5); // Bonus for successfully eating
                        this.successfulActions++;
                        
                        // Show learning sparkle
                        showLearningSparkle(this.thronglet.x, this.thronglet.y, "+Food");
                    }
                }
                
                if (this.lastAction === 'moveToBall') {
                    const approachChange = oldState.nearestBall - newState.nearestBall;
                    
                    // If happiness is low, provide higher reward for approaching ball
                    const happinessUrgency = Math.max(0, 1 - newState.happiness); // 0 when happy, 1 when sad
                    
                    // Gradually increase reward as we approach the ball correctly
                    if (approachChange > 0) {
                        reward += approachChange * (1 + happinessUrgency); // Getting closer is good, especially when sad
                    } else {
                        // Small penalty for moving away from ball when sad
                        reward -= Math.abs(approachChange) * happinessUrgency * 0.5;
                    }
                    
                    // Bigger reward if the action was successful
                    if (happinessChange > 0) {
                        reward += 0.5 + (happinessUrgency * 0.5); // Bonus for successfully playing
                        this.successfulActions++;
                        
                        // Show learning sparkle
                        showLearningSparkle(this.thronglet.x, this.thronglet.y, "+Play");
                    }
                }
                
                // Reward coordination with other Thronglets
                if (this.lastAction === 'moveToThronglet') {
                    const approachChange = oldState.nearestThronglet - newState.nearestThronglet;
                    if (approachChange > 0) {
                        reward += approachChange * 0.5; // Modest reward for approaching other Thronglets
                    }
                }
                
                // Penalty for very low hunger or happiness
                if (newState.hunger < 0.2) reward -= 0.2; // Penalty for extreme hunger
                if (newState.happiness < 0.2) reward -= 0.1; // Penalty for extreme unhappiness
                
                // Add to intelligence score if reward is positive
                if (reward > 0) {
                    this.intelligenceScore += reward * 0.1;
                    
                    // Track learning progress in global context
                    if (Math.random() < 0.1) { // Only track occasionally to avoid spamming
                        addThrongletMemory(this.thronglet.id, 'learning', 
                            `I learned more about ${this.lastAction || 'behavior'} with reward of ${reward.toFixed(2)}`);
                    }
                }
                
                return reward;
            }
            
            // Update the agent's learning based on the observed reward
            updateLearning(reward) {
                if (observationPhase) return; // Don't update during observation
                
                this.lastReward = reward;
                this.totalReward += reward;
                
                // Find the most recent action record for this Thronglet
                const recentActions = stateActionHistory.filter(
                    record => record.throngletId === this.id
                ).slice(-5);
                
                if (recentActions.length > 0) {
                    // Update most recent action record
                    const lastActionRecord = recentActions[recentActions.length - 1];
                    lastActionRecord.reward = reward;
                    
                    // Update weights based on the reward
                    this.updateWeights(lastActionRecord, reward);
                }
            }
            
            // Update the weights based on the reward
            updateWeights(actionRecord, reward) {
                const state = actionRecord.state;
                const action = actionRecord.action;
                
                // Base learning rate, adjusted by reward magnitude
                const effectiveLearningRate = this.learningRate * (Math.abs(reward) + 0.1);
                
                // Update state-based weights
                this.weights.hunger += effectiveLearningRate * reward * (1 - state.hunger);
                this.weights.happiness += effectiveLearningRate * reward * state.happiness;
                this.weights.nearestApple += effectiveLearningRate * reward * (1 - state.nearestApple);
                this.weights.nearestBall += effectiveLearningRate * reward * (1 - state.nearestBall);
                this.weights.nearestThronglet += effectiveLearningRate * reward * (1 - state.nearestThronglet);
                
                // Update action-specific weight
                if (action === 'moveToApple') {
                    this.weights.moveToApple += effectiveLearningRate * reward;
                } else if (action === 'moveToBall') {
                    this.weights.moveToBall += effectiveLearningRate * reward;
                } else if (action === 'moveToThronglet') {
                    this.weights.moveToThronglet += effectiveLearningRate * reward;
                } else if (action === 'moveRandom') {
                    this.weights.moveRandom += effectiveLearningRate * reward;
                } else if (action === 'beep') {
                    this.weights.beep += effectiveLearningRate * reward;
                }
                
                // Normalize weights to prevent extreme values
                this.normalizeWeights();
            }
            
            // Normalize weights to keep them in a reasonable range
            normalizeWeights() {
                const maxWeight = 5.0;
                const minWeight = -1.0;
                
                for (const key in this.weights) {
                    this.weights[key] = Math.max(minWeight, Math.min(maxWeight, this.weights[key]));
                }
            }
            
            // Check if another Thronglet responded to this agent's beep
            checkBeepResponses() {
                if (!this.lastBeepPattern || Date.now() - this.lastBeepTime > 5000) return;
                
                // Look for other Thronglets that moved towards this one after the beep
                const respondingThronglets = [];
                
                for (const otherThronglet of thronglets) {
                    if (otherThronglet.id === this.id) continue;
                    
                    // Check if the other Thronglet is moving towards this one
                    if (otherThronglet.isMoving && 
                        otherThronglet.targetX && otherThronglet.targetY &&
                        Math.abs(otherThronglet.targetX - this.thronglet.x) < 30 &&
                        Math.abs(otherThronglet.targetY - this.thronglet.y) < 30) {
                        
                        respondingThronglets.push(otherThronglet);
                    }
                }
                
                if (respondingThronglets.length > 0) {
                    // There was a response!
                    const responseReward = 0.5; // Good reward for successful communication
                    
                    // Update the communication scores and rewards
                    this.lastBeepPattern.rewards += responseReward;
                    this.communicationScore += responseReward;
                    
                    // Also reward the responding Thronglets
                    for (const responder of respondingThronglets) {
                        // Find the agent for this Thronglet
                        const responderAgent = responder.agent;
                        if (responderAgent) {
                            responderAgent.teamworkScore += responseReward;
                            responderAgent.communicationScore += responseReward / 2;
                            
                            // Record teamwork event
                            teamworkEvents.push({
                                type: 'communication_response',
                                initiatorId: this.id,
                                responderId: responder.id,
                                pattern: this.lastBeepPattern,
                                timestamp: Date.now(),
                                reward: responseReward
                            });
                        }
                    }
                    
                    // Clear the beep to prevent double-counting
                    this.lastBeepPattern = null;
                }
            }
            
            // Check for teamwork opportunities
            checkTeamworkOpportunities() {
                // Check for nearby Thronglets
                const nearbyThronglets = [];
                
                for (const otherThronglet of thronglets) {
                    if (otherThronglet.id === this.id) continue;
                    
                    const distance = Math.sqrt(
                        Math.pow(this.thronglet.x - otherThronglet.x, 2) + 
                        Math.pow(this.thronglet.y - otherThronglet.y, 2)
                    );
                    
                    if (distance < 80) { // Close enough for teamwork
                        nearbyThronglets.push(otherThronglet);
                    }
                }
                
                // If there are nearby Thronglets, consider teamwork
                if (nearbyThronglets.length > 0) {
                    // Chance to engage in teamwork increases with number of nearby Thronglets
                    const teamworkChance = 0.1 * nearbyThronglets.length;
                    
                    if (Math.random() < teamworkChance) {
                        // Attempt teamwork!
                        this.initiateTeamwork(nearbyThronglets);
                    }
                }
            }
            
            // Initiate teamwork with nearby Thronglets
            initiateTeamwork(nearbyThronglets) {
                // Basic teamwork: Moving together (synchronized movement)
                // This could be expanded to more complex behaviors
                
                // Choose a random direction for all to move
                const borderPadding = 80;
                const targetX = borderPadding + Math.random() * (sceneWidth - 2 * borderPadding);
                const targetY = borderPadding + Math.random() * (sceneHeight - 2 * borderPadding);
                
                // Show thought about teamwork
                this.thronglet.showThought("Let's go together!");
                
                // Move this Thronglet
                this.thronglet.moveTowards(targetX, targetY);
                
                // Signal the nearby Thronglets to follow
                for (const otherThronglet of nearbyThronglets) {
                    const otherAgent = otherThronglet.agent;
                    if (otherAgent) {
                        // 50% chance for other Thronglet to follow
                        if (Math.random() < 0.5) {
                            otherThronglet.showThought("I'll follow you!");
                            otherThronglet.moveTowards(targetX, targetY);
                            
                            // Record teamwork event
                            teamworkEvents.push({
                                type: 'move_together',
                                initiatorId: this.id,
                                participantId: otherThronglet.id,
                                targetX: targetX,
                                targetY: targetY,
                                timestamp: Date.now()
                            });
                            
                            // Reward both Thronglets for teamwork
                            const teamworkReward = 0.3;
                            this.teamworkScore += teamworkReward;
                            otherAgent.teamworkScore += teamworkReward;
                        }
                    }
                }
            }
            
            // Get the Thronglet's intelligence growth metrics
            getIntelligenceMetrics() {
                return {
                    intelligenceScore: this.intelligenceScore,
                    teamworkScore: this.teamworkScore,
                    communicationScore: this.communicationScore,
                    totalScore: this.intelligenceScore + this.teamworkScore + this.communicationScore,
                    successRate: this.iterations > 0 ? this.successfulActions / this.iterations : 0
                };
            }
        }

        // Add global agent management functions after other functions, near the end of the file:
        // Add agent management functions
        function setupAgentLearningSystem() {
            // Any initial setup for learning system
            
            // Start agent update cycle
            setInterval(() => {
                if (gameActive && agentLearningEnabled) {
                    updateAgentLearning();
                }
            }, 5000); // Update agent metrics every 5 seconds
            
            // Gradually reduce exploration rate as agents learn
            setInterval(() => {
                if (gameActive && agentLearningEnabled && !observationPhase) {
                    explorationRate = Math.max(0.05, explorationRate - 0.01); // Reduce gradually to a minimum of 0.05
                }
            }, 30000); // Every 30 seconds
            
            // Start hidden layers doubling every 3 minutes
            lastHiddenLayersUpdate = Date.now();
            setInterval(updateHiddenLayers, 1000); // Check every second, but only update every 3 minutes
            
            console.log("Agent learning system initialized!");
        }

        // Function to double hidden layers every 3 minutes
        function updateHiddenLayers() {
            if (!gameActive || !lastHiddenLayersUpdate) return;
            
            const currentTime = Date.now();
            const minutesPassed = (currentTime - lastHiddenLayersUpdate) / (60 * 1000);
            
            // If 3 minutes have passed
            if (minutesPassed >= 3) {
                // Double the hidden layers
                hiddenLayersCount = hiddenLayersCount * 2;
                lastHiddenLayersUpdate = currentTime;
                
                // Show a message to users
                message.textContent = `Hidden layers doubled to ${hiddenLayersCount}!`;
                
                // Update the layers counter in visualizer if it exists
                const layersCounter = document.getElementById('layers-counter');
                if (layersCounter) {
                    layersCounter.textContent = `Hidden Layers: ${hiddenLayersCount}`;
                }
                
                // Notify a random Thronglet about the neural network growth
                if (thronglets.length > 0) {
                    const randomIndex = Math.floor(Math.random() * thronglets.length);
                    const randomThronglet = thronglets[randomIndex];
                    randomThronglet.showThought(`I feel smarter! My neural network now has ${hiddenLayersCount} hidden layers!`);
                    
                    // Show learning sparkle
                    showLearningSparkle(randomThronglet.x, randomThronglet.y, `${hiddenLayersCount} Layers!`);
                }
                
                console.log(`Hidden layers doubled to ${hiddenLayersCount}`);
            }
        }

        // Update agent learning metrics
        function updateAgentLearning() {
            let totalIntelligence = 0;
            let totalTeamwork = 0;
            let totalCommunication = 0;
            
            // Update metrics for each Thronglet's agent
            for (const thronglet of thronglets) {
                if (thronglet.agent) {
                    const metrics = thronglet.agent.getIntelligenceMetrics();
                    totalIntelligence += metrics.intelligenceScore;
                    totalTeamwork += metrics.teamworkScore;
                    totalCommunication += metrics.communicationScore;
                }
            }
            
            // Update UI or log information if needed
            if (thronglets.length > 0) {
                console.log(`Agent Learning Metrics - Intelligence: ${totalIntelligence.toFixed(2)}, Teamwork: ${totalTeamwork.toFixed(2)}, Communication: ${totalCommunication.toFixed(2)}`);
            }
        }
        
        // Add learning stats display
        function showLearningStats() {
            let stats = "THRONGLET LEARNING STATS:\n\n";
            
            // Show global stats
            stats += `Observation Phase: ${observationPhase ? "Active" : "Completed"}\n`;
            stats += `Learning Rate: ${learningRate.toFixed(3)}\n`;
            stats += `Exploration Rate: ${explorationRate.toFixed(3)}\n\n`;
            
            // Show stats for each Thronglet
            for (const thronglet of thronglets) {
                if (thronglet.agent) {
                    const metrics = thronglet.agent.getIntelligenceMetrics();
                    stats += `Thronglet #${thronglet.id}:\n`;
                    stats += `  Intelligence: ${metrics.intelligenceScore.toFixed(2)}\n`;
                    stats += `  Teamwork: ${metrics.teamworkScore.toFixed(2)}\n`;
                    stats += `  Communication: ${metrics.communicationScore.toFixed(2)}\n`;
                    stats += `  Success Rate: ${(metrics.successRate * 100).toFixed(1)}%\n\n`;
                }
            }
            
            // Show communication patterns learning
            stats += "COMMUNICATION PATTERNS:\n";
            beepPatterns.forEach(pattern => {
                stats += `  "${pattern.meaning}": ${pattern.uses} uses, ${pattern.rewards.toFixed(2)} rewards\n`;
            });
            
            // Show teamwork events count
            const recentTeamworkEvents = teamworkEvents.slice(-20);
            stats += `\nRECENT TEAMWORK EVENTS: ${recentTeamworkEvents.length}\n`;
            
            alert(stats);
        }

        // Add brain visualizer functionality
        let activeBrainVisualization = null;
        let selectedThrongletId = null;
        let visualizerUpdateInterval = null;
        
        function openBrainVisualizer() {
            const modal = document.getElementById('brain-visualizer-modal');
            modal.style.display = 'block';
            
            // Update the layers counter
            const layersCounter = document.getElementById('layers-counter');
            if (layersCounter) {
                layersCounter.textContent = `Hidden Layers: ${hiddenLayersCount}`;
            }
            
            // Set the canvas to be visible as well
            const canvas = document.getElementById('brain-canvas');
            canvas.style.display = 'block';
            
            // Make sure the canvas has proper dimensions
            canvas.width = 700;
            canvas.height = 400;
            
            // Populate the Thronglet selector
            updateThrongletSelector();
            
            // Setup close button
            const closeButton = modal.querySelector('.close-button');
            closeButton.onclick = () => {
                modal.style.display = 'none';
                stopVisualizerUpdates();
            };
            
            // Close if clicking outside the modal content
            window.onclick = (event) => {
                if (event.target === modal) {
                    modal.style.display = 'none';
                    stopVisualizerUpdates();
                }
            };
            
            // Close neuron info when clicking on the modal content background
            const modalContent = modal.querySelector('.modal-content');
            modalContent.addEventListener('click', (event) => {
                // Only if clicking directly on the modal content (not on children)
                if (event.target === modalContent) {
                    document.getElementById('neuron-info').textContent = 'Select a neuron to see its details';
                }
            });
            
            // Close neuron info when clicking on the visualizer container background
            const visualizerContainer = modal.querySelector('.visualizer-container');
            visualizerContainer.addEventListener('click', (event) => {
                // Only if clicking directly on the container (not on canvas or info panel)
                if (event.target === visualizerContainer) {
                    document.getElementById('neuron-info').textContent = 'Select a neuron to see its details';
                }
            });
            
            // Setup Thronglet selector change event
            const selector = document.getElementById('thronglet-selector');
            selector.onchange = function() {
                selectedThrongletId = parseInt(this.value);
                if (selectedThrongletId) {
                    console.log("Selected Thronglet ID: " + selectedThrongletId);
                    initBrainVisualization(selectedThrongletId);
                    startVisualizerUpdates();
                } else {
                    stopVisualizerUpdates();
                    clearCanvas();
                }
            };
            
            // Automatically select the first Thronglet if available
            if (selector.options.length > 1) {
                selector.selectedIndex = 1; // Select the first Thronglet
                selectedThrongletId = parseInt(selector.value);
                if (selectedThrongletId) {
                    console.log("Auto-selected Thronglet ID: " + selectedThrongletId);
                    initBrainVisualization(selectedThrongletId);
                    startVisualizerUpdates();
                }
            }
            
            // Setup update speed control
            const speedControl = document.getElementById('update-speed');
            speedControl.onchange = function() {
                if (visualizerUpdateInterval) {
                    stopVisualizerUpdates();
                    startVisualizerUpdates();
                }
            };
            
            // Initialize with empty canvas
            clearCanvas();
            
            console.log("Brain visualizer opened");
        }
        
        function updateThrongletSelector() {
            const selector = document.getElementById('thronglet-selector');
            
            // Clear existing options except the first one
            while (selector.options.length > 1) {
                selector.remove(1);
            }
            
            // Add an option for each Thronglet
            thronglets.forEach(thronglet => {
                if (thronglet.agent) { // Only include Thronglets with agents
                    const option = document.createElement('option');
                    option.value = thronglet.id;
                    option.textContent = `Thronglet #${thronglet.id}`;
                    selector.appendChild(option);
                }
            });
        }
        
        function clearCanvas() {
            const canvas = document.getElementById('brain-canvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Show message if no Thronglet selected
            if (!selectedThrongletId) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Select a Thronglet to visualize its neural network', canvas.width / 2, canvas.height / 2);
            }
            
            // Clear neuron info
            document.getElementById('neuron-info').textContent = 'Select a neuron to see its details';
            }
        
        function initBrainVisualization(throngletId) {
            // Find the Thronglet
            const thronglet = thronglets.find(t => t.id === throngletId);
            if (!thronglet || !thronglet.agent) return;
            
            const agent = thronglet.agent;
            
            // Create visualization data structure
            activeBrainVisualization = {
                throngletId: throngletId,
                neurons: {},
                lastAction: agent.lastAction,
                weights: agent.weights
            };
            
            // Define the number of layers and neurons
            const TOTAL_LAYERS = 2 + hiddenLayersCount; // Input, variable hidden layers, output
            const NEURONS_PER_HIDDEN_LAYER = 6;
            
            // Canvas dimensions
            const canvas = document.getElementById('brain-canvas');
            const width = canvas.width;
            const height = canvas.height;
            
            // Layout parameters
            const inputX = 80;
            const outputX = width - 80;
            const layerSpacing = (outputX - inputX) / (TOTAL_LAYERS - 1);
            
            // Input layer neurons
            const inputNeuronNames = ['hunger', 'happiness', 'nearestApple', 'nearestBall', 'nearestThronglet', 'applesCount', 'ballsCount', 'throngletsCount'];
            const inputYSpacing = height / (inputNeuronNames.length + 1);
            
            inputNeuronNames.forEach((name, index) => {
                activeBrainVisualization.neurons[name] = {
                    x: inputX,
                    y: inputYSpacing * (index + 1),
                    value: agent.currentState[name] || 0,
                    type: 'input',
                    connections: []
                };
            });
            
            // Hidden layers
            for (let layer = 0; layer < TOTAL_LAYERS - 2; layer++) {
                const layerX = inputX + layerSpacing * (layer + 1);
                const hiddenYSpacing = height / (NEURONS_PER_HIDDEN_LAYER + 1);
                
                for (let i = 0; i < NEURONS_PER_HIDDEN_LAYER; i++) {
                    const neuronName = `hidden${layer+1}_${i+1}`;
                    const jitterX = (Math.random() - 0.5) * 10; // Add slight horizontal jitter
                    const jitterY = (Math.random() - 0.5) * 10; // Add slight vertical jitter
                    
                    activeBrainVisualization.neurons[neuronName] = {
                        x: layerX + jitterX,
                        y: hiddenYSpacing * (i + 1) + jitterY,
                        value: 0,
                        type: 'hidden',
                        layer: layer + 1,
                        connections: []
                    };
                }
            }
            
            // Output layer neurons
            const outputNeuronNames = ['moveToApple', 'moveToBall', 'moveToThronglet', 'moveRandom', 'beep'];
            const outputYSpacing = height / (outputNeuronNames.length + 1);
            
            outputNeuronNames.forEach((name, index) => {
                activeBrainVisualization.neurons[name] = {
                    x: outputX,
                    y: outputYSpacing * (index + 1),
                    value: 0,
                    type: 'output',
                    connections: []
                };
            });
            
            // Generate connections between layers
            // 1. Input to first hidden layer
            const firstHiddenLayer = Object.keys(activeBrainVisualization.neurons)
                .filter(name => name.startsWith('hidden1_'));
                
            for (const inputName of inputNeuronNames) {
                for (const hiddenName of firstHiddenLayer) {
                    // Create weighted connection based on agent's weights
                    const weight = (agent.weights[inputName] || 0.1) * (Math.random() * 0.8 + 0.6);
                    
                    activeBrainVisualization.neurons[inputName].connections.push({
                        target: hiddenName,
                        weight: weight
                    });
                }
            }
            
            // 2. Connections between hidden layers
            for (let layer = 1; layer < TOTAL_LAYERS - 2; layer++) {
                const currentLayer = Object.keys(activeBrainVisualization.neurons)
                    .filter(name => name.startsWith(`hidden${layer}_`));
                const nextLayer = Object.keys(activeBrainVisualization.neurons)
                    .filter(name => name.startsWith(`hidden${layer+1}_`));
                
                for (const sourceName of currentLayer) {
                    // Each neuron connects to approximately half of the neurons in the next layer
                    const targetCount = Math.max(1, Math.floor(nextLayer.length * 0.5));
                    const shuffledTargets = [...nextLayer].sort(() => Math.random() - 0.5);
                    const selectedTargets = shuffledTargets.slice(0, targetCount);
                    
                    for (const targetName of selectedTargets) {
                        const weight = Math.random() * 2 - 1; // Random weight between -1 and 1
                        
                        activeBrainVisualization.neurons[sourceName].connections.push({
                            target: targetName,
                            weight: weight
                        });
                    }
                }
            }
            
            // 3. Last hidden layer to output layer
            const lastHiddenLayer = Object.keys(activeBrainVisualization.neurons)
                .filter(name => name.startsWith(`hidden${TOTAL_LAYERS-2}_`));
                
            for (const hiddenName of lastHiddenLayer) {
                for (const outputName of outputNeuronNames) {
                    // Create weighted connection based on agent's weights
                    const weight = (agent.weights[outputName] || 0.1) * (Math.random() * 0.8 + 0.6);
                    
                    activeBrainVisualization.neurons[hiddenName].connections.push({
                        target: outputName,
                        weight: weight
                    });
                }
            }
            
            // Add Morse code concept neurons
            addConceptNeurons(thronglet);
            
            // Set up canvas click handler for neuron inspection
            canvas.onclick = handleCanvasClick;
            
            // Draw initial state
            updateBrainVisualization();
        }
        
        // Add Morse code concept neurons to the brain visualization
        function addConceptNeurons(thronglet) {
            if (!activeBrainVisualization) return;
            
            // Make sure throngletLanguage exists
            if (typeof throngletLanguage === 'undefined' || !throngletLanguage) {
                console.warn("throngletLanguage is not defined, skipping concept neurons");
                return;
            }
            
            // Make sure the getKnownConcepts function exists
            if (typeof throngletLanguage.getKnownConcepts !== 'function') {
                console.warn("throngletLanguage.getKnownConcepts is not a function, skipping concept neurons");
                return;
            }
            
            // Get concepts this Thronglet knows
            const knownConcepts = throngletLanguage.getKnownConcepts(thronglet);
            if (!knownConcepts || knownConcepts.length === 0) return;
            
            // Position concept neurons at the top right area of the canvas, away from output neurons
            const canvas = document.getElementById('brain-canvas');
            const width = canvas.width;
            const height = canvas.height;
            
            // Position concepts above and to the right of the outputs
            const outputX = width - 80; // X position of output neurons
            const conceptX = width - 130; // X position of concept neurons (more to the left)
            const startY = 70; // Start higher than output neurons
            
            // Calculate vertical spacing based on number of concepts
            const verticalSpace = Math.min(height - 150, 300); // Available vertical space
            const conceptSpacing = Math.max(25, verticalSpace / (knownConcepts.length + 1));
            
            // Create concept neurons
            knownConcepts.forEach((concept, index) => {
                const neuronName = `concept_${concept}`;
                
                // Make sure getPatternForConcept function exists
                if (typeof throngletLanguage.getPatternForConcept !== 'function') {
                    console.warn(`throngletLanguage.getPatternForConcept is not a function for concept: ${concept}`);
                    return;
                }
                
                // Try to get pattern, use a fallback if it fails
                let conceptPattern;
                try {
                    conceptPattern = throngletLanguage.getPatternForConcept(concept);
                } catch (e) {
                    console.warn(`Error getting pattern for concept ${concept}:`, e);
                    conceptPattern = []; // Fallback to empty pattern
                }
                
                activeBrainVisualization.neurons[neuronName] = {
                    x: conceptX,
                    y: startY + (index * conceptSpacing),
                    value: Math.random() * 0.5 + 0.5, // Initialize with semi-active state
                    type: 'concept',
                    concept: concept,
                    pattern: conceptPattern,
                    connections: []
                };
                
                // Connect from hidden layer to this concept neuron
                const lastHiddenLayer = Object.keys(activeBrainVisualization.neurons)
                    .filter(name => name.startsWith(`hidden3_`));
                
                // Connect a few random hidden neurons to this concept
                const connectionCount = Math.min(3, lastHiddenLayer.length);
                const randomHiddenNeurons = [...lastHiddenLayer].sort(() => Math.random() - 0.5).slice(0, connectionCount);
                
                for (const hiddenName of randomHiddenNeurons) {
                    const weight = Math.random() * 0.6 + 0.4; // Positive weight between 0.4 and 1.0
                    
                    activeBrainVisualization.neurons[hiddenName].connections.push({
                        target: neuronName,
                        weight: weight
                    });
                }
                
                // Connect from this concept neuron to the beep output with a strong connection
                activeBrainVisualization.neurons[neuronName].connections.push({
                    target: 'beep',
                    weight: 0.8 // Strong connection to beep output
                });
            });
        }
        
        function updateBrainVisualization() {
            if (!activeBrainVisualization) return;
            
            // Find the current Thronglet
            const thronglet = thronglets.find(t => t.id === activeBrainVisualization.throngletId);
            if (!thronglet || !thronglet.agent) return;
            
            const agent = thronglet.agent;
            
            // Get canvas dimensions - Make sure width is defined
            const canvas = document.getElementById('brain-canvas');
            const width = canvas.width;
            const height = canvas.height;
            
            // Update input neuron values from current state
            for (const name in agent.currentState) {
                if (activeBrainVisualization.neurons[name]) {
                    activeBrainVisualization.neurons[name].value = agent.currentState[name];
                }
            }
            
            // Add learning metrics for food and ball interactions
            if (!activeBrainVisualization.neurons['food_learning']) {
                // Add a special neuron to visualize food learning progress
                const eatenMemories = (globalContext.throngletMemory[thronglet.id] || [])
                    .filter(m => m.type === 'apple_eaten');
                const foodLearningValue = Math.min(1.0, eatenMemories.length / 3);
                
                activeBrainVisualization.neurons['food_learning'] = {
                    x: width - 200, // Position it to the left of outputs
                    y: 100,
                    value: foodLearningValue,
                    type: 'learning',
                    connections: []
                };
                
                // Connect it to the moveToApple output
                if (activeBrainVisualization.neurons['moveToApple']) {
                    activeBrainVisualization.neurons['food_learning'].connections.push({
                        target: 'moveToApple',
                        weight: foodLearningValue * 0.8 + 0.2 // Strong connection based on learning
                    });
                }
                
                // Connect relevant input neurons to food learning neuron
                if (activeBrainVisualization.neurons['hunger']) {
                    activeBrainVisualization.neurons['hunger'].connections.push({
                        target: 'food_learning',
                        weight: 0.7 // Strong connection between hunger and food learning
                    });
                }
                
                if (activeBrainVisualization.neurons['nearestApple']) {
                    activeBrainVisualization.neurons['nearestApple'].connections.push({
                        target: 'food_learning',
                        weight: 0.6 // Connection between apple proximity and food learning
                    });
                }
                
                if (activeBrainVisualization.neurons['applesCount']) {
                    activeBrainVisualization.neurons['applesCount'].connections.push({
                        target: 'food_learning',
                        weight: 0.5 // Connection between apple count and food learning
                    });
                }
            }
            
            if (!activeBrainVisualization.neurons['play_learning']) {
                // Add a special neuron to visualize ball interaction learning progress
                const kickedMemories = (globalContext.throngletMemory[thronglet.id] || [])
                    .filter(m => m.type === 'ball_kicked');
                const playLearningValue = Math.min(1.0, kickedMemories.length / 3);
                
                activeBrainVisualization.neurons['play_learning'] = {
                    x: width - 200, // Position it to the left of outputs
                    y: 150,
                    value: playLearningValue,
                    type: 'learning',
                    connections: []
                };
                
                // Connect it to the moveToBall output
                if (activeBrainVisualization.neurons['moveToBall']) {
                    activeBrainVisualization.neurons['play_learning'].connections.push({
                        target: 'moveToBall',
                        weight: playLearningValue * 0.8 + 0.2 // Strong connection based on learning
                    });
                }
                
                // Connect relevant input neurons to play learning neuron
                if (activeBrainVisualization.neurons['happiness']) {
                    activeBrainVisualization.neurons['happiness'].connections.push({
                        target: 'play_learning',
                        weight: 0.7 // Strong connection between happiness and play learning
                    });
                }
                
                if (activeBrainVisualization.neurons['nearestBall']) {
                    activeBrainVisualization.neurons['nearestBall'].connections.push({
                        target: 'play_learning',
                        weight: 0.6 // Connection between ball proximity and play learning
                    });
                }
                
                if (activeBrainVisualization.neurons['ballsCount']) {
                    activeBrainVisualization.neurons['ballsCount'].connections.push({
                        target: 'play_learning',
                        weight: 0.5 // Connection between ball count and play learning
                    });
                }
            }
            
            // Update values for learning neurons
            if (activeBrainVisualization.neurons['food_learning']) {
                const eatenMemories = (globalContext.throngletMemory[thronglet.id] || [])
                    .filter(m => m.type === 'apple_eaten');
                activeBrainVisualization.neurons['food_learning'].value = Math.min(1.0, eatenMemories.length / 3);
            }
            
            if (activeBrainVisualization.neurons['play_learning']) {
                const kickedMemories = (globalContext.throngletMemory[thronglet.id] || [])
                    .filter(m => m.type === 'ball_kicked');
                activeBrainVisualization.neurons['play_learning'].value = Math.min(1.0, kickedMemories.length / 3);
            }
            
            // Update last action
            activeBrainVisualization.lastAction = agent.lastAction;
            
            // Perform forward propagation through the network
            
            // 1. Identify layers in order
            const inputNeurons = Object.keys(activeBrainVisualization.neurons)
                .filter(name => activeBrainVisualization.neurons[name].type === 'input')
                .map(name => activeBrainVisualization.neurons[name]);
                
            // Sort hidden neurons by layer
            const hiddenNeuronsByLayer = {};
            for (const name in activeBrainVisualization.neurons) {
                const neuron = activeBrainVisualization.neurons[name];
                if (neuron.type === 'hidden') {
                    const layer = neuron.layer || parseInt(name.match(/hidden(\d+)/)[1]);
                    if (!hiddenNeuronsByLayer[layer]) {
                        hiddenNeuronsByLayer[layer] = [];
                    }
                    hiddenNeuronsByLayer[layer].push(neuron);
                }
            }
            
            const outputNeurons = Object.keys(activeBrainVisualization.neurons)
                .filter(name => activeBrainVisualization.neurons[name].type === 'output')
                .map(name => activeBrainVisualization.neurons[name]);
                
            const conceptNeurons = Object.keys(activeBrainVisualization.neurons)
                .filter(name => activeBrainVisualization.neurons[name].type === 'concept')
                .map(name => activeBrainVisualization.neurons[name]);
                
            // 2. Forward propagation through hidden layers
            // (Input values are already set)
            
            // Process each hidden layer in sequence
            const hiddenLayers = Object.keys(hiddenNeuronsByLayer).sort((a, b) => parseInt(a) - parseInt(b));
            
            for (const layer of hiddenLayers) {
                const neurons = hiddenNeuronsByLayer[layer];
                
                // For each neuron in this layer
                for (const neuron of neurons) {
                    // Find all incoming connections to this neuron
                    let sum = 0;
                    let connectionCount = 0;
                    
                    // Get neuron name
                    const neuronName = Object.keys(activeBrainVisualization.neurons).find(
                        name => activeBrainVisualization.neurons[name] === neuron
                    );
                    
                    // Check all possible source neurons that might connect to this one
                    for (const sourceName in activeBrainVisualization.neurons) {
                        const sourceNeuron = activeBrainVisualization.neurons[sourceName];
                        
                        // Find connections from source to this neuron
                        for (const connection of sourceNeuron.connections) {
                            if (connection.target === neuronName) {
                                sum += sourceNeuron.value * connection.weight;
                                connectionCount++;
                            }
                        }
                    }
                    
                    // Apply tanh activation function
                    neuron.value = connectionCount > 0 ? Math.tanh(sum) : 0;
                }
            }
            
            // 3. Calculate concept neuron values
            for (const conceptNeuron of conceptNeurons) {
                let sum = 0;
                let connectionCount = 0;
                
                // Get neuron name
                const neuronName = Object.keys(activeBrainVisualization.neurons).find(
                    name => activeBrainVisualization.neurons[name] === conceptNeuron
                );
                
                // Find all neurons that connect to this concept
                for (const sourceName in activeBrainVisualization.neurons) {
                    const sourceNeuron = activeBrainVisualization.neurons[sourceName];
                    
                    // Check if this source connects to our concept
                    for (const connection of sourceNeuron.connections) {
                        if (connection.target === neuronName) {
                            sum += sourceNeuron.value * connection.weight;
                            connectionCount++;
                        }
                    }
                }
                
                // Apply sigmoid activation for concept layer
                conceptNeuron.value = connectionCount > 0 ? 1 / (1 + Math.exp(-sum)) : conceptNeuron.value * 0.95;
                
                // Add some noise/activity based on recent usage of this concept
                if (thronglet.lastConceptUse && thronglet.lastConceptUse[conceptNeuron.concept]) {
                    const timeSinceUse = Date.now() - thronglet.lastConceptUse[conceptNeuron.concept];
                    if (timeSinceUse < 5000) { // If used in last 5 seconds
                        conceptNeuron.value = Math.min(1.0, conceptNeuron.value + 0.3);
                    }
                }
            }
            
            // 4. Calculate output neuron values
            for (const outputNeuron of outputNeurons) {
                let sum = 0;
                let connectionCount = 0;
                
                // Get output neuron name
                const outputNeuronName = Object.keys(activeBrainVisualization.neurons).find(
                    name => activeBrainVisualization.neurons[name] === outputNeuron
                );
                
                // Find all neurons that connect to this output
                for (const sourceName in activeBrainVisualization.neurons) {
                    const sourceNeuron = activeBrainVisualization.neurons[sourceName];
                    
                    // Check if this source connects to our output
                    for (const connection of sourceNeuron.connections) {
                        if (connection.target === outputNeuronName) {
                            sum += sourceNeuron.value * connection.weight;
                            connectionCount++;
                        }
                    }
                }
                
                // Apply sigmoid activation for output layer
                outputNeuron.value = connectionCount > 0 ? 1 / (1 + Math.exp(-sum)) : 0;
            }
            
            // Draw the network
            drawBrainNetwork();
        }
        
        function drawBrainNetwork() {
            const ctx = document.getElementById('brain-canvas').getContext('2d');
            const canvas = document.getElementById('brain-canvas');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw title and legend
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.font = '16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`Thronglet #${activeBrainVisualization.throngletId} Brain Visualization`, canvas.width / 2, 25);
            
            // Draw timestamp and last action
            ctx.font = '12px Arial';
            ctx.textAlign = 'right';
            ctx.fillText(`Last updated: ${new Date().toLocaleTimeString()}`, canvas.width - 20, 20);
            ctx.textAlign = 'left';
            ctx.fillText(`Last action: ${activeBrainVisualization.lastAction || 'None'}`, 20, 20);
            
            // Draw layer labels
            ctx.textAlign = 'center';
            ctx.fillText('Input', 80, 50);
            ctx.fillText('Output', canvas.width - 80, 50);
            ctx.fillText('Hidden Layers', canvas.width / 2, 50);
            
            // Add a learning section label for the learning neurons
            ctx.font = '14px Arial';
            ctx.fillStyle = 'rgba(46, 204, 113, 0.9)'; // Green color for learning section
            ctx.textAlign = 'center';
            ctx.fillText('Learning Progress', canvas.width - 200, 70);
            
            // Draw a light box around the learning area if we have learning neurons
            const learningNeurons = Object.values(activeBrainVisualization.neurons)
                .filter(n => n.type === 'learning');
            
            if (learningNeurons.length > 0) {
                // Find the boundaries of learning neurons
                let minY = 1000, maxY = 0;
                learningNeurons.forEach(n => {
                    minY = Math.min(minY, n.y - 20);
                    maxY = Math.max(maxY, n.y + 20);
                });
                
                // Draw a rounded rectangle around the learning area
                ctx.beginPath();
                const rectX = canvas.width - 250;
                const rectWidth = 120;
                const rectHeight = maxY - minY + 30;
                
                // Rounded rectangle
                ctx.roundRect(rectX, minY - 15, rectWidth, rectHeight, 10);
                ctx.strokeStyle = 'rgba(46, 204, 113, 0.3)';
                ctx.lineWidth = 1;
                ctx.stroke();
                
                // Draw subtle background
                ctx.fillStyle = 'rgba(46, 204, 113, 0.05)';
                ctx.fill();
            }
            
            // Draw concept layer label if we have concept neurons - more prominently
            const hasConcepts = Object.values(activeBrainVisualization.neurons).some(n => n.type === 'concept');
            if (hasConcepts) {
                ctx.font = '14px Arial';
                ctx.fillStyle = 'rgba(255, 215, 0, 0.9)'; // Golden color for concept section
                ctx.textAlign = 'center';
                ctx.fillText('Concepts', canvas.width - 130, 40);
                
                // Draw a light box around the concept area
                const conceptNeurons = Object.values(activeBrainVisualization.neurons)
                    .filter(n => n.type === 'concept');
                
                if (conceptNeurons.length > 0) {
                    // Find the boundaries of concept neurons
                    let minY = 1000, maxY = 0;
                    conceptNeurons.forEach(n => {
                        minY = Math.min(minY, n.y - 20);
                        maxY = Math.max(maxY, n.y + 20);
                    });
                    
                    // Draw a rounded rectangle around the concept area
                    ctx.beginPath();
                    const rectX = canvas.width - 190;
                    const rectWidth = 120;
                    const rectHeight = maxY - minY + 30;
                    
                    // Rounded rectangle
                    ctx.roundRect(rectX, minY - 15, rectWidth, rectHeight, 10);
                    ctx.strokeStyle = 'rgba(255, 215, 0, 0.3)';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    
                    // Draw subtle background
                    ctx.fillStyle = 'rgba(255, 215, 0, 0.05)';
                    ctx.fill();
                }
            }
            
            // Draw connections first (so they appear behind neurons)
            ctx.lineWidth = 0.5;
            for (const sourceName in activeBrainVisualization.neurons) {
                const sourceNeuron = activeBrainVisualization.neurons[sourceName];
                
                for (const connection of sourceNeuron.connections) {
                    const targetNeuron = activeBrainVisualization.neurons[connection.target];
                    if (!targetNeuron) continue;
                    
                    // Calculate line properties based on weight and activation
                    const weight = connection.weight;
                    const value = sourceNeuron.value;
                    
                    // Determine line width based on connection strength
                    const lineWidth = Math.max(0.5, Math.min(3, Math.abs(weight) * 2));
                    
                    // Determine opacity based on activation
                    let alpha = Math.min(0.8, Math.max(0.1, Math.abs(value * weight) * 0.8 + 0.1));
                    
                    // Determine color based on sign of weight and neuron types
                    let color;
                    
                    // Special case for connections to/from concept neurons
                    if (sourceNeuron.type === 'concept' || targetNeuron.type === 'concept') {
                        // Gold color for concept connections
                        color = `rgba(255, 215, 0, ${alpha})`;
                    } else if (weight >= 0) {
                        color = `rgba(50, 205, 50, ${alpha})`; // Green for positive
                    } else {
                        color = `rgba(255, 69, 0, ${alpha})`; // Red for negative
                    }
                    
                    // Draw connection with bezier curve for better visualization
                    ctx.beginPath();
                    ctx.strokeStyle = color;
                    ctx.lineWidth = lineWidth;
                    
                    // Use bezier curves for connections to make them more visually distinct
                    const midX = (sourceNeuron.x + targetNeuron.x) / 2;
                    const midY = (sourceNeuron.y + targetNeuron.y) / 2;
                    
                    // Calculate control points for the curve
                    let controlX = midX;
                    let controlY = midY;
                    
                    // If it's a connection involving a concept, add more curve
                    if (sourceNeuron.type === 'concept' || targetNeuron.type === 'concept') {
                        controlX += (sourceNeuron.y < targetNeuron.y) ? 40 : -40;
                        controlY += (sourceNeuron.x < targetNeuron.x) ? 40 : -40;
                    }
                    
                    // Draw the bezier curve
                    ctx.moveTo(sourceNeuron.x, sourceNeuron.y);
                    ctx.quadraticCurveTo(controlX, controlY, targetNeuron.x, targetNeuron.y);
                    ctx.stroke();
                }
            }
            
            // Now draw all neurons on top
            for (const neuronName in activeBrainVisualization.neurons) {
                const neuron = activeBrainVisualization.neurons[neuronName];
                
                // Determine neuron color based on type and activation
                let color;
                let size = 12; // Default size
                
                if (neuron.type === 'input') {
                    // Input neurons: blue when active
                    color = `rgba(30, 144, 255, ${0.3 + Math.abs(neuron.value) * 0.7})`;
                } else if (neuron.type === 'hidden') {
                    // Hidden neurons: purple with intensity based on activation
                    // Map tanh value from [-1, 1] to [0, 1]
                    const intensity = (Math.tanh(neuron.value) + 1) / 2;
                    color = `rgba(138, 43, 226, ${0.3 + intensity * 0.7})`;
                    size = 8; // Smaller size for hidden neurons
                } else if (neuron.type === 'concept') {
                    // Concept neurons: gold/yellow with intensity based on activation
                    color = `rgba(255, 215, 0, ${0.3 + neuron.value * 0.7})`;
                    size = 14; // Slightly larger for concept neurons
                    
                    // Draw morse pattern around concept neurons
                    if (neuron.pattern) {
                        ctx.beginPath();
                        ctx.arc(neuron.x, neuron.y, size + 5, 0, Math.PI * 2);
                        ctx.strokeStyle = 'rgba(255, 215, 0, 0.5)';
                        ctx.setLineDash([2, 2]);
                        ctx.lineWidth = 1;
                        ctx.stroke();
                        ctx.setLineDash([]);
                    }
                } else if (neuron.type === 'learning') {
                    // Learning neurons: green with intensity based on learning progress
                    color = `rgba(46, 204, 113, ${0.3 + neuron.value * 0.7})`;
                    size = 15; // Larger for learning neurons
                    
                    // Draw progress indicator around learning neurons
                    ctx.beginPath();
                    // Draw an arc representing the progress (from 0 to 2π based on value)
                    ctx.arc(neuron.x, neuron.y, size + 5, 0, Math.PI * 2 * neuron.value);
                    ctx.strokeStyle = 'rgba(46, 204, 113, 0.8)';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    
                    // Draw the incomplete part of the circle with a thinner, less opaque line
                    if (neuron.value < 1.0) {
                        ctx.beginPath();
                        ctx.arc(neuron.x, neuron.y, size + 5, Math.PI * 2 * neuron.value, Math.PI * 2);
                        ctx.strokeStyle = 'rgba(46, 204, 113, 0.2)';
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    }
                } else {
                    // Output neurons: green when active
                    color = `rgba(50, 205, 50, ${0.3 + neuron.value * 0.7})`;
                    
                    // Highlight currently selected action
                    if (neuronName === activeBrainVisualization.lastAction) {
                        // Draw highlight ring
                        ctx.beginPath();
                        ctx.arc(neuron.x, neuron.y, size + 5, 0, Math.PI * 2);
                        ctx.strokeStyle = 'rgba(255, 215, 0, 0.8)'; // Gold
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }
                }
                
                // Draw neuron circle
                ctx.beginPath();
                ctx.arc(neuron.x, neuron.y, size, 0, Math.PI * 2);
                ctx.fillStyle = color;
                ctx.fill();
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.lineWidth = 1;
                ctx.stroke();
                
                // Draw labels for input, output and concept neurons only
                if (neuron.type === 'input' || neuron.type === 'output') {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.font = '11px Arial';
                    ctx.textAlign = 'center';
                    
                    // Format the name to be more readable
                    const formattedName = neuronName
                        .replace(/([A-Z])/g, ' $1') // Add space before capital letters
                        .replace(/^./, str => str.toUpperCase()); // Capitalize first letter
                    
                    const xOffset = neuron.type === 'input' ? -50 : 50;
                    ctx.fillText(formattedName, neuron.x + xOffset, neuron.y);
                    
                    // Draw value
                    ctx.font = '10px Arial';
                    ctx.fillText(neuron.value.toFixed(2), neuron.x, neuron.y + 4);
                } else if (neuron.type === 'hidden') {
                    // For hidden neurons, just draw value inside
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.font = '8px Arial';
                    ctx.fillText(neuron.value.toFixed(1), neuron.x, neuron.y + 3);
                } else if (neuron.type === 'concept') {
                    // For concept neurons, draw concept name and morse pattern
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.font = '11px Arial';
                    ctx.textAlign = 'right';
                    
                    // Show concept name
                    ctx.fillText(neuron.concept, neuron.x - 18, neuron.y);
                    
                    // Show morse pattern below
                    ctx.font = '9px monospace';
                    ctx.fillText(neuron.pattern, neuron.x - 18, neuron.y + 12);
                    
                    // Draw value
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(neuron.value.toFixed(2), neuron.x, neuron.y + 4);
                } else if (neuron.type === 'learning') {
                    // For learning neurons, draw learning type and progress percentage
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.font = '11px Arial';
                    ctx.textAlign = 'right';
                    
                    // Find the neuron name
                    const neuronName = Object.keys(activeBrainVisualization.neurons).find(
                        name => activeBrainVisualization.neurons[name] === neuron
                    );
                    
                    // Show learning type name
                    let displayName = neuronName === 'food_learning' ? 'Food Learning' : 'Play Learning';
                    ctx.fillText(displayName, neuron.x - 20, neuron.y);
                    
                    // Show progress percentage inside
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(`${Math.round(neuron.value * 100)}%`, neuron.x, neuron.y + 4);
                }
            }
        }
        
        function handleCanvasClick(event) {
            if (!activeBrainVisualization) return;
            
            const canvas = document.getElementById('brain-canvas');
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            // Check if clicked on a neuron
            let clickedNeuron = null;
            let minDistance = 15; // Minimum distance to consider a click on a neuron
            
            for (const neuronName in activeBrainVisualization.neurons) {
                const neuron = activeBrainVisualization.neurons[neuronName];
                const distance = Math.sqrt(Math.pow(neuron.x - x, 2) + Math.pow(neuron.y - y, 2));
                
                if (distance < minDistance) {
                    clickedNeuron = neuron;
                    minDistance = distance;
                }
            }
            
            // Display neuron information
            const infoElement = document.getElementById('neuron-info');
            if (clickedNeuron) {
                // Find neuron name
                const neuronName = Object.keys(activeBrainVisualization.neurons).find(
                    name => activeBrainVisualization.neurons[name] === clickedNeuron
                );
                
                let info = `<strong>Neuron: ${neuronName}</strong><br>`;
                info += `Type: ${clickedNeuron.type}<br>`;
                info += `Value: ${clickedNeuron.value.toFixed(3)}<br>`;
                
                // Add extra info for concept neurons
                if (clickedNeuron.type === 'concept') {
                    info += `Concept: ${clickedNeuron.concept}<br>`;
                    info += `Morse Pattern: ${clickedNeuron.pattern}<br>`;
                    
                    // Find when this concept was last used
                    const thronglet = thronglets.find(t => t.id === activeBrainVisualization.throngletId);
                    if (thronglet && thronglet.lastConceptUse && thronglet.lastConceptUse[clickedNeuron.concept]) {
                        const lastUsed = new Date(thronglet.lastConceptUse[clickedNeuron.concept]);
                        info += `Last Used: ${lastUsed.toLocaleTimeString()}<br>`;
                    }
                }
                
                // Show extra info for learning neurons
                if (clickedNeuron.type === 'learning') {
                    // Find the neuron name
                    const neuronName = Object.keys(activeBrainVisualization.neurons).find(
                        name => activeBrainVisualization.neurons[name] === clickedNeuron
                    );
                    
                    // Display learning information
                    const thronglet = thronglets.find(t => t.id === activeBrainVisualization.throngletId);
                    const throngletId = thronglet ? thronglet.id : 'unknown';
                    
                    // Show different info based on learning type
                    if (neuronName === 'food_learning') {
                        // Show food learning progress
                        const eatenMemories = (globalContext.throngletMemory[throngletId] || [])
                            .filter(m => m.type === 'apple_eaten');
                            
                        info += `Learning Progress: ${Math.round(clickedNeuron.value * 100)}%<br>`;
                        info += `Apples Eaten: ${eatenMemories.length}<br>`;
                        info += `Learning Phase: ${eatenMemories.length < 3 ? 'Active' : 'Complete'}<br>`;
                        
                        // Show last apple eaten time if available
                        if (eatenMemories.length > 0) {
                            const lastEaten = eatenMemories[eatenMemories.length - 1];
                            if (lastEaten.timestamp) {
                                const lastTime = new Date(lastEaten.timestamp);
                                info += `Last Eaten: ${lastTime.toLocaleTimeString()}<br>`;
                            }
                        }
                    } else if (neuronName === 'play_learning') {
                        // Show play learning progress
                        const kickedMemories = (globalContext.throngletMemory[throngletId] || [])
                            .filter(m => m.type === 'ball_kicked');
                            
                        info += `Learning Progress: ${Math.round(clickedNeuron.value * 100)}%<br>`;
                        info += `Balls Kicked: ${kickedMemories.length}<br>`;
                        info += `Learning Phase: ${kickedMemories.length < 3 ? 'Active' : 'Complete'}<br>`;
                        
                        // Show last ball kicked time if available
                        if (kickedMemories.length > 0) {
                            const lastKicked = kickedMemories[kickedMemories.length - 1];
                            if (lastKicked.timestamp) {
                                const lastTime = new Date(lastKicked.timestamp);
                                info += `Last Kicked: ${lastTime.toLocaleTimeString()}<br>`;
                            }
                        }
                    }
                }
                
                // Show connections
                if (clickedNeuron.connections.length > 0) {
                    info += '<br><strong>Outgoing Connections:</strong><br>';
                    clickedNeuron.connections.forEach(conn => {
                        info += `→ ${conn.target} (weight: ${conn.weight.toFixed(3)})<br>`;
                    });
                }
                
                // Show incoming connections
                const incomingConnections = [];
                for (const sourceName in activeBrainVisualization.neurons) {
                    const sourceNeuron = activeBrainVisualization.neurons[sourceName];
                    for (const conn of sourceNeuron.connections) {
                        if (conn.target === neuronName) {
                            incomingConnections.push({
                                source: sourceName,
                                weight: conn.weight
                            });
                        }
                    }
                }
                
                if (incomingConnections.length > 0) {
                    info += '<br><strong>Incoming Connections:</strong><br>';
                    incomingConnections.forEach(conn => {
                        info += `← ${conn.source} (weight: ${conn.weight.toFixed(3)})<br>`;
                    });
                }
                
                infoElement.innerHTML = info;
            } else {
                infoElement.textContent = 'Select a neuron to see its details';
            }
        }
        
        function startVisualizerUpdates() {
            // Stop any existing interval first
            stopVisualizerUpdates();
            
            // Get update speed
            const updateSpeed = parseInt(document.getElementById('update-speed').value);
            console.log("Starting visualizer updates with speed: " + updateSpeed + "ms");
            
            // Start new update interval
            visualizerUpdateInterval = setInterval(updateBrainVisualization, updateSpeed);
            
            // Force an immediate update
            updateBrainVisualization();
        }
        
        function stopVisualizerUpdates() {
            if (visualizerUpdateInterval) {
                console.log("Stopping visualizer updates");
                clearInterval(visualizerUpdateInterval);
                visualizerUpdateInterval = null;
            }
        }

        function playBeepSound(thronglet, text) {
            if (!audioContext) {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.error('Web Audio API is not supported in this browser');
                    return;
                }
            }
            
            // Determine the base frequency for this Thronglet (unique "voice")
            const baseFrequency = 260 + (thronglet.id % 15) * 6; // Range from ~260-350 Hz
            
            // Check if text contains any morse code patterns
            const morsePatterns = extractMorsePatterns(text);
            
            // Add animation if not already animating
            if (!thronglet.element.classList.contains('thronglet-beep')) {
                thronglet.element.classList.add('thronglet-beep');
                setTimeout(() => {
                    thronglet.element.classList.remove('thronglet-beep');
                }, 600);
            }
            
            if (morsePatterns.length > 0) {
                // Play morse code sequence if patterns are found
                playMorseSequence(thronglet, morsePatterns, baseFrequency);
            } else {
                // Play regular single beep
                playSingleBeep(thronglet, baseFrequency);
            }
        }
        
        function playSingleBeep(thronglet, baseFrequency) {
            // Main oscillator
            const oscillator = audioContext.createOscillator();
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(baseFrequency, audioContext.currentTime);
            
            // Create harmonizer for richer sound
            const harmonizer = audioContext.createOscillator();
            harmonizer.type = 'sine';
            harmonizer.frequency.setValueAtTime(baseFrequency * 1.5, audioContext.currentTime); // Perfect fifth
            
            // Create gain nodes for volume control
            const gainNode = audioContext.createGain();
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(0.15, audioContext.currentTime + 0.05);
            gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.2);
            
            const harmonizerGain = audioContext.createGain();
            harmonizerGain.gain.setValueAtTime(0, audioContext.currentTime);
            harmonizerGain.gain.linearRampToValueAtTime(0.07, audioContext.currentTime + 0.05);
            harmonizerGain.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.2);
            
            // Connect nodes
            oscillator.connect(gainNode);
            harmonizer.connect(harmonizerGain);
            gainNode.connect(audioContext.destination);
            harmonizerGain.connect(audioContext.destination);
            
            // Play the sound
            oscillator.start();
            harmonizer.start();
            
            // Stop after duration
            oscillator.stop(audioContext.currentTime + 0.2);
            harmonizer.stop(audioContext.currentTime + 0.2);
        }
        
        // Function to extract morse patterns from text
        function extractMorsePatterns(text) {
            const patterns = [];
            
            // Check if text is defined
            if (!text) {
                console.warn("extractMorsePatterns called with undefined or empty text");
                return patterns;
            }
            
            // Look for patterns that might be Morse code
            if (text.includes(".") || text.includes("-")) {
                // Identify word boundaries in potential Morse segments
                const words = text.split(/\s+/);
                
                for (const word of words) {
                    // Check if the word looks like Morse code (only dots, dashes, and spaces)
                    if (/^[-.\s]+$/.test(word) && word.length >= 2) {
                        patterns.push(word.trim());
                    }
                }
                
                // If no individual words were found, try to find sequences in the whole text
                if (patterns.length === 0) {
                    const morseRegex = /[-.\s]{2,}/g;
                    const matches = text.match(morseRegex);
                    
                    if (matches) {
                        matches.forEach(match => {
                            if (/^[-.\s]+$/.test(match)) {
                                patterns.push(match.trim());
                            }
                        });
                    }
                }
            }
            
            // Also look for exact matches to concept patterns in the language system
            // Make sure throngletLanguage and concepts exist before trying to access them
            if (throngletLanguage && throngletLanguage.concepts) {
                // Check if concepts is a Map (class-based version) or a regular object (original version)
                if (throngletLanguage.concepts instanceof Map) {
                    // If it's a Map, iterate using keys()
                    for (const [pattern, concept] of throngletLanguage.concepts.entries()) {
                        if (text.includes(pattern) && !patterns.includes(pattern)) {
                            patterns.push(pattern);
                        }
                    }
                } else {
                    // If it's a regular object, use Object.values
                    for (const pattern of Object.values(throngletLanguage.concepts)) {
                        if (text.includes(pattern) && !patterns.includes(pattern)) {
                            patterns.push(pattern);
                        }
                    }
                }
            } else {
                console.warn("throngletLanguage.concepts is not defined when extracting Morse patterns");
            }
            
            return patterns;
        }
        
        // Play a sequence of morse code
        function playMorseSequence(thronglet, patterns, baseFrequency) {
            // Convert the patterns to timing sequence
            let currentTime = 0;
            const timeUnit = 0.08; // Duration of a dot in seconds
            
            // Function to schedule a single beep
            function scheduleBeep(startTime, duration, isHarmonic = false) {
                // Main oscillator
                const oscillator = audioContext.createOscillator();
                oscillator.type = 'sine';
                
                // Determine frequency - either base or harmonic
                const freq = isHarmonic ? baseFrequency * 1.5 : baseFrequency;
                oscillator.frequency.setValueAtTime(freq, audioContext.currentTime + startTime);
                
                // Create gain node for volume control
                const gainNode = audioContext.createGain();
                gainNode.gain.setValueAtTime(0, audioContext.currentTime + startTime);
                gainNode.gain.linearRampToValueAtTime(isHarmonic ? 0.07 : 0.15, audioContext.currentTime + startTime + 0.01);
                gainNode.gain.linearRampToValueAtTime(isHarmonic ? 0.07 : 0.15, audioContext.currentTime + startTime + duration - 0.01);
                gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + startTime + duration);
                
                // Connect and play
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                oscillator.start(audioContext.currentTime + startTime);
                oscillator.stop(audioContext.currentTime + startTime + duration);
            }
            
            // Limit to at most 8 beeps to prevent audio overload
            let beepCount = 0;
            const maxBeeps = 8;
            
            // Schedule beeps for each pattern
            for (const pattern of patterns) {
                for (let i = 0; i < pattern.length && beepCount < maxBeeps; i++) {
                    const char = pattern.charAt(i);
                    
                    if (char === '.') {
                        // Dot - short beep
                        scheduleBeep(currentTime, timeUnit);
                        scheduleBeep(currentTime, timeUnit, true); // Add harmonic
                        currentTime += timeUnit * 1.2; // Add a tiny gap
                        beepCount++;
                    } else if (char === '-') {
                        // Dash - longer beep
                        scheduleBeep(currentTime, timeUnit * 3);
                        scheduleBeep(currentTime, timeUnit * 3, true); // Add harmonic
                        currentTime += timeUnit * 3.2; // Add a tiny gap
                        beepCount++;
                    } else if (char === ' ') {
                        // Space between characters
                        currentTime += timeUnit * 3;
                    }
                }
                
                // Add pause between patterns
                currentTime += timeUnit * 2;
                
                // Stop if we've reached the max beep count
                if (beepCount >= maxBeeps) break;
            }
            
            // Add the pattern to the Thronglet's learning if using the class-based implementation
            if (thronglet && throngletLanguage.addPatternToThronglet) {
                throngletLanguage.addPatternToThronglet(thronglet, patterns[0]);
            }
        }
        
        // Basic Morse code translation
        function textToMorse(text) {
            const morseMap = {
                'a': '.-', 'b': '-...', 'c': '-.-.', 'd': '-..', 'e': '.', 
                'f': '..-.', 'g': '--.', 'h': '....', 'i': '..', 'j': '.---',
                'k': '-.-', 'l': '.-..', 'm': '--', 'n': '-.', 'o': '---',
                'p': '.--.', 'q': '--.-', 'r': '.-.', 's': '...', 't': '-',
                'u': '..-', 'v': '...-', 'w': '.--', 'x': '-..-', 'y': '-.--',
                'z': '--..', '1': '.----', '2': '..---', '3': '...--', '4': '....-',
                '5': '.....', '6': '-....', '7': '--...', '8': '---..', '9': '----.',
                '0': '-----', ' ': ' '
            };
            
            let morse = '';
            text = text.toLowerCase();
            
            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                if (morseMap[char]) {
                    morse += morseMap[char] + ' ';
                }
            }
            
            return morse.trim();
        }
        
        function morseToText(morse) {
            const textMap = {
                '.-': 'a', '-...': 'b', '-.-.': 'c', '-..': 'd', '.': 'e', 
                '..-.': 'f', '--.': 'g', '....': 'h', '..': 'i', '.---': 'j',
                '-.-': 'k', '.-..': 'l', '--': 'm', '-.': 'n', '---': 'o',
                '.--.': 'p', '--.-': 'q', '.-.': 'r', '...': 's', '-': 't',
                '..-': 'u', '...-': 'v', '.--': 'w', '-..-': 'x', '-.--': 'y',
                '--..': 'z', '.----': '1', '..---': '2', '...--': '3', '....-': '4',
                '.....': '5', '-....': '6', '--...': '7', '---..': '8', '----.': '9',
                '-----': '0'
            };
            
            let text = '';
            const parts = morse.split(' ');
            
            for (let i = 0; i < parts.length; i++) {
                const part = parts[i];
                if (part === '') {
                    text += ' ';
                } else if (textMap[part]) {
                    text += textMap[part];
                }
            }
            
            return text;
        }

        function startThrongletConversation(thronglet1, thronglet2) {
            // Check if either Thronglet is already in a conversation
            if (thronglet1.isInConversation || thronglet2.isInConversation) {
                return false;
            }
            
            // Mark both Thronglets as in conversation
            thronglet1.isInConversation = true;
            thronglet2.isInConversation = true;
            
            // Have them face each other
            const dx = thronglet2.x - thronglet1.x;
            const dy = thronglet2.y - thronglet1.y;
            thronglet1.direction = Math.atan2(dy, dx);
            thronglet2.direction = Math.atan2(-dy, -dx);
            
            // Make them move closer if they're far apart
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance > 80) {
                // Move halfway toward each other
                const midX = (thronglet1.x + thronglet2.x) / 2;
                const midY = (thronglet1.y + thronglet2.y) / 2;
                
                // Calculate positions that are a bit apart
                const offsetDistance = 40; // how far apart they should be
                const angle = Math.atan2(dy, dx);
                
                const t1TargetX = midX - Math.cos(angle) * offsetDistance;
                const t1TargetY = midY - Math.sin(angle) * offsetDistance;
                const t2TargetX = midX + Math.cos(angle) * offsetDistance;
                const t2TargetY = midY + Math.sin(angle) * offsetDistance;
                
                // Animate movement
                animateThrongletMove(thronglet1, t1TargetX, t1TargetY, () => {
                    animateThrongletMove(thronglet2, t2TargetX, t2TargetY, () => {
                        exchangeMessages(thronglet1, thronglet2);
                    });
                });
            } else {
                // They're already close enough
                exchangeMessages(thronglet1, thronglet2);
            }
            
            // Messaging function
            function exchangeMessages(t1, t2) {
                // First message from thronglet1
                generateConversationMessage(t1, t2).then(message => {
                    showThought(t1, message);
                    
                    // Learn from conversation
                    learnFromConversation(t2, t1, message);
                    
                    // Wait a bit before the reply
                setTimeout(() => {
                        // Reply from thronglet2
                        generateConversationMessage(t2, t1, message).then(reply => {
                            showThought(t2, reply);
                            
                            // Learn from conversation
                            learnFromConversation(t1, t2, reply);
                            
                            // Maybe continue the conversation
                            if (Math.random() < 0.3) {
                                setTimeout(() => {
                                    generateConversationMessage(t1, t2, reply).then(followUp => {
                                        showThought(t1, followUp);
                                        learnFromConversation(t2, t1, followUp);
                                        
                                        // End conversation
                                        setTimeout(endConversation, 5000);
                                    });
                                }, 3000);
                            } else {
                                // End conversation
                                setTimeout(endConversation, 5000);
                            }
                        });
                    }, 4000);
                });
            }
            
            function endConversation() {
                thronglet1.isInConversation = false;
                thronglet2.isInConversation = false;
                
                // Add chance for a Thronglet to learn Morse if they've interacted multiple times
                const interactionCount = (thronglet1.conversationHistory || []).filter(c => c.partner === thronglet2.id).length;
                
                if (interactionCount > 2 && Math.random() < 0.4) {
                    // Generate a meaningful Morse code exchange
                    setTimeout(() => {
                        // One of the Thronglets teaches the other Morse code
                        const teacher = Math.random() < 0.5 ? thronglet1 : thronglet2;
                        const student = teacher === thronglet1 ? thronglet2 : thronglet1;
                        
                        // Create a simple Morse code lesson
                        const letters = ['s', 'o', 's', 'h', 'i', 'e', 't'];
                        const letter = letters[Math.floor(Math.random() * letters.length)];
                        const morseCode = textToMorse(letter);
                        
                        // Teacher shows the Morse code
                        showThought(teacher, `${morseCode}`);
                        
                        setTimeout(() => {
                            // Student learns and repeats
                            if (!student.morsePatterns) {
                                student.morsePatterns = [];
                            }
                            if (!student.morsePatterns.includes(morseCode)) {
                                student.morsePatterns.push(morseCode);
                            }
                            
                            // Visual indication of learning
                            createLearningSparkle(student.element);
                            
                            // Student repeats the pattern
                            setTimeout(() => {
                                showThought(student, `${morseCode}`);
                            }, 1500);
                        }, 2500);
                    }, 2000);
                }
            }
            
            return true;
        }
        
        // Learn from conversation
        function learnFromConversation(thronglet, otherThronglet, message) {
            // Initialize conversation history if not exists
            if (!thronglet.conversationHistory) {
                thronglet.conversationHistory = [];
            }
            
            // Store conversation in history
            thronglet.conversationHistory.push({
                partner: otherThronglet.id,
                message: message,
                timestamp: Date.now()
            });
            
            // Limit history size
            if (thronglet.conversationHistory.length > 10) {
                thronglet.conversationHistory.shift();
            }
            
            // Morse code learning - chance to learn morse patterns from other Thronglets
            if (otherThronglet.morsePatterns && otherThronglet.morsePatterns.length > 0 && Math.random() < 0.4) {
                if (!thronglet.morsePatterns) {
                    thronglet.morsePatterns = [];
                }
                
                // Learn a random morse pattern
                const randomIndex = Math.floor(Math.random() * otherThronglet.morsePatterns.length);
                const patternToLearn = otherThronglet.morsePatterns[randomIndex];
                
                if (!thronglet.morsePatterns.includes(patternToLearn)) {
                    thronglet.morsePatterns.push(patternToLearn);
                    // Limit array size
                    if (thronglet.morsePatterns.length > 10) {
                        thronglet.morsePatterns.shift();
                    }
                    
                    // Visual indication of learning (small spark animation)
                    createLearningSparkle(thronglet.element);
                }
            }
        }
        
        // Function to create a sparkle effect when a Thronglet learns something
        function createLearningSparkle(thronglet, concept) {
            // Create sparkle element
            const sparkle = document.createElement('div');
            sparkle.className = 'learning-sparkle';
            
            // Position it above the Thronglet
            sparkle.style.left = thronglet.x + 'px';
            sparkle.style.top = (thronglet.y - 30) + 'px';
            
            // Add concept name if provided
            if (concept) {
                sparkle.textContent = concept;
                
                // Different colors for different concepts
                switch(concept) {
                    case 'food':
                        sparkle.style.color = '#e74c3c'; // Red
                            break;
                    case 'happy':
                        sparkle.style.color = '#f1c40f'; // Yellow
                            break;
                    case 'sad':
                        sparkle.style.color = '#3498db'; // Blue
                            break;
                    case 'follow':
                        sparkle.style.color = '#2ecc71'; // Green
                            break;
                    default:
                        sparkle.style.color = '#9b59b6'; // Purple
                }
            }
            
            // Add to the game container
            document.getElementById('game-container').appendChild(sparkle);
            
            // Remove after animation
            setTimeout(() => {
                if (sparkle.parentNode) {
                    sparkle.parentNode.removeChild(sparkle);
                }
            }, 2000);
        }

        // Set up natural learning based on Thronglet experiences
        function setupNaturalConceptLearning() {
            console.log("Setting up natural concept learning...");
            
            // Setup a monitoring interval to check Thronglet behavior
            window.throngletMovementMonitor = setInterval(function() {
                for (const thronglet of thronglets) {
                    console.log(`Checking learning for Thronglet #${thronglet.id}: Happiness=${thronglet.happiness}, Hunger=${thronglet.hunger}`);
                    
                    // Debug which conditions are being met
                    const nearApple = thronglet.checkForApple && typeof thronglet.checkForApple === 'function' ? thronglet.checkForApple() : false;
                    const isFollowing = thronglet.followingThrongletId ? true : false;
                    const isHappy = thronglet.happiness > 60;
                    const isSad = thronglet.happiness < 30;
                    
                    console.log(`Thronglet #${thronglet.id} conditions: nearApple=${nearApple}, isFollowing=${isFollowing}, isHappy=${isHappy}, isSad=${isSad}`);
                    
                    // Learn "food" concept when eating apple
                    if (nearApple) {
                        console.log(`Thronglet #${thronglet.id} is near an apple!`);
                        // Higher chance to learn when hungry - INCREASED from 0.75 to 0.95
                        const learnChance = 0.95;
                        if (Math.random() < learnChance) {
                            console.log(`Attempting to teach food concept to Thronglet #${thronglet.id}`);
                            if (throngletLanguage.learnConcept(thronglet, "food")) {
                                console.log(`SUCCESS: Thronglet #${thronglet.id} learned food concept!`);
                                createLearningSparkle(thronglet, "food");
                                
                                // Show the newly learned concept
                                const pattern = throngletLanguage.getPatternForConcept("food");
                                showThought(thronglet, pattern);
                                
                                // Add to neural network if agent exists
                                integrateConceptToNeuralNetwork(thronglet, "food");
                            } else {
                                console.log(`FAILED: Thronglet #${thronglet.id} already knows food concept`);
                            }
                        }
                    }
                    
                    // Learn follow concept - already at 95% chance, good
                    if (isFollowing) {
                        console.log(`Thronglet #${thronglet.id} is following another Thronglet`);
                        // Very high chance to learn (95%)
                        if (Math.random() < 0.95) {
                            console.log(`Attempting to teach follow concept to Thronglet #${thronglet.id}`);
                            if (throngletLanguage.learnConcept(thronglet, "follow")) {
                                console.log(`SUCCESS: Thronglet #${thronglet.id} learned follow concept!`);
                                createLearningSparkle(thronglet, "follow");
                                
                                // Show the newly learned concept
                                const pattern = throngletLanguage.getPatternForConcept("follow");
                                showThought(thronglet, pattern);
                                
                                // Add to neural network if agent exists
                                integrateConceptToNeuralNetwork(thronglet, "follow");
                            } else {
                                console.log(`FAILED: Thronglet #${thronglet.id} already knows follow concept`);
                            }
                        }
                    }
                    
                    // Happy concept - already at 90% chance, good
                    if (isHappy) {
                        console.log(`Thronglet #${thronglet.id} is happy (${thronglet.happiness})`);
                        if (Math.random() < 0.9) {
                            console.log(`Attempting to teach happy concept to Thronglet #${thronglet.id} (happiness: ${thronglet.happiness})`);
                            if (throngletLanguage.learnConcept(thronglet, "happy")) {
                                console.log(`SUCCESS: Thronglet #${thronglet.id} learned happy concept!`);
                                createLearningSparkle(thronglet, "happy");
                                
                                // Show the newly learned concept
                                const pattern = throngletLanguage.getPatternForConcept("happy");
                                showThought(thronglet, pattern);
                                
                                // Add to neural network if agent exists
                                integrateConceptToNeuralNetwork(thronglet, "happy");
                            } else {
                                console.log(`FAILED: Thronglet #${thronglet.id} already knows happy concept`);
                            }
                        }
                    } 
                    // Sad concept - INCREASE from 0.1 to 0.9 to match other concepts
                    else if (isSad) {
                        console.log(`Thronglet #${thronglet.id} is sad (${thronglet.happiness})`);
                        if (Math.random() < 0.9) {
                            console.log(`Attempting to teach sad concept to Thronglet #${thronglet.id} (happiness: ${thronglet.happiness})`);
                            if (throngletLanguage.learnConcept(thronglet, "sad")) {
                                console.log(`SUCCESS: Thronglet #${thronglet.id} learned sad concept!`);
                                createLearningSparkle(thronglet, "sad");
                                
                                // Show the newly learned concept
                                const pattern = throngletLanguage.getPatternForConcept("sad");
                                showThought(thronglet, pattern);
                                
                                // Add to neural network if agent exists
                                integrateConceptToNeuralNetwork(thronglet, "sad");
                            } else {
                                console.log(`FAILED: Thronglet #${thronglet.id} already knows sad concept`);
                            }
                        }
                    }
                }
            }, 1000);
            
            // Initialize the concept learning for each Thronglet
            // Make sure all Thronglets have at least one concept at random
            setTimeout(() => {
                console.log("Initializing concepts for Thronglets...");
                
                for (const thronglet of thronglets) {
                    console.log(`Setting up initial concepts for Thronglet #${thronglet.id}`);
                    
                    // Reset any existing concepts to ensure clean learning
                    thronglet.knownConcepts = [];
                    thronglet.lastConceptUse = {}; // Track when concepts were last used
                    
                    // Make sure creator Thronglet gets all concepts
                    if (thronglet.id === 0) {
                        // Creator gets all concepts
                        const concepts = ["food", "happy", "sad", "follow"];
                        for (const concept of concepts) {
                            throngletLanguage.learnConcept(thronglet, concept);
                            console.log(`Creator Thronglet learned ${concept} concept`);
                            // Add to neural network
                            integrateConceptToNeuralNetwork(thronglet, concept);
                            
                            // Show the concepts in order with delay
                            setTimeout(() => {
                                const pattern = throngletLanguage.getPatternForConcept(concept);
                                showThought(thronglet, pattern);
                            }, 1000 * concepts.indexOf(concept));
                        }
                    } else {
                        // Give each non-creator Thronglet one random concept to start with
                        const concepts = ["food", "happy", "sad", "follow"];
                        const randomConcept = concepts[Math.floor(Math.random() * concepts.length)];
                        throngletLanguage.learnConcept(thronglet, randomConcept);
                        console.log(`Thronglet #${thronglet.id} learned initial ${randomConcept} concept`);
                        
                        // Add to neural network
                        integrateConceptToNeuralNetwork(thronglet, randomConcept);
                        
                        // Show the concept with a slight delay
                        setTimeout(() => {
                            const pattern = throngletLanguage.getPatternForConcept(randomConcept);
                            showThought(thronglet, pattern);
                        }, 500);
                    }
                }
            }, 2000); // Wait 2 seconds after setup
            
            // Fix checkForApple for Thronglets
            patchThrongletCheckForApple();
        }
        
        // Fix the checkForApple function to properly detect apples
        function patchThrongletCheckForApple() {
            console.log("Patching Thronglet checkForApple function");
            
            // Check if Thronglet prototype has the checkForApple function
            if (typeof Thronglet.prototype.checkForApple !== 'function') {
                console.log("Adding checkForApple to Thronglet prototype");
                
                Thronglet.prototype.checkForApple = function() {
                    // Check for nearby apples
                    for (const apple of apples) {
                        const dx = apple.x - this.x;
                        const dy = apple.y - this.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < 50) {
                            console.log(`Thronglet #${this.id} found an apple nearby!`);
                            return true;
                        }
                    }
                    return false;
                };
            } else {
                console.log("Thronglet already has checkForApple function");
            }
        }

        // Initialize Morse code system after game starts
        document.addEventListener('DOMContentLoaded', function() {
            // Call after the game has initialized
            setTimeout(() => {
                console.log("Morse code communication system enabled");
                
                // Give the creator Thronglet initial Morse code knowledge
                if (thronglets.length > 0) {
                    const creatorThronglet = thronglets[0];
                    if (!creatorThronglet.morsePatterns) {
                        creatorThronglet.morsePatterns = ['... --- ...', '.-', '.-..', '.'];
                    }
                }
            }, 3000);
        });

        // Learning rules for concepts - using the class-based ThrongletLanguage
        function initializeConceptLearning() {
            // No need to call throngletLanguage.init() as we're using the class version
            
            // Give creator Thronglet some initial concepts
            if (thronglets.length > 0) {
                const creatorThronglet = thronglets[0];
                
                // Initialize concept knowledge using the class-based methods
                if (!creatorThronglet.knownConcepts) {
                    creatorThronglet.knownConcepts = ['food', 'happy', 'sad', 'follow', 'yes', 'no'];
                    
                    // Add patterns to morsePatterns for each known concept
                    if (!creatorThronglet.morsePatterns) {
                        creatorThronglet.morsePatterns = [];
                    }
                    
                    for (const concept of creatorThronglet.knownConcepts) {
                        const pattern = throngletLanguage.getPatternForConcept(concept);
                        if (pattern && !creatorThronglet.morsePatterns.includes(pattern)) {
                            creatorThronglet.morsePatterns.push(pattern);
                        }
                    }
                }
            }
            
            // Add event listeners for natural learning
            setupNaturalConceptLearning();
        }

        class ThrongletLanguage {
            constructor() {
                this.concepts = new Map();
                this.patterns = new Map();
                this.learningRate = 0.05;
                
                // Initialize with some basic concepts
                this.addConcept("food", ".-");
                this.addConcept("happy", "..");
                this.addConcept("sad", "...");
                this.addConcept("follow", "--.");
            }
            
            addConcept(concept, pattern) {
                this.concepts.set(pattern, concept);
                this.patterns.set(concept, pattern);
            }
            
            getConceptFromPattern(pattern) {
                return this.concepts.get(pattern);
            }
            
            getPatternForConcept(concept) {
                return this.patterns.get(concept);
            }
            
            getThrongletKnownPatterns(thronglet) {
                if (!thronglet.knownConcepts) {
                    thronglet.knownConcepts = [];
                    thronglet.lastConceptUse = {}; // Track when concepts were last used
                }
                
                return thronglet.knownConcepts.map(concept => this.getPatternForConcept(concept));
            }
            
            learnConcept(thronglet, concept) {
                if (!thronglet.knownConcepts) {
                    thronglet.knownConcepts = [];
                    thronglet.lastConceptUse = {};
                }
                
                if (!thronglet.knownConcepts.includes(concept)) {
                    thronglet.knownConcepts.push(concept);
                    console.log(`Thronglet #${thronglet.id} learned the concept: ${concept}`);
                    return true;
                }
                return false;
            }
            
            useConcept(thronglet, concept) {
                if (!thronglet.lastConceptUse) {
                    thronglet.lastConceptUse = {};
                }
                
                // Record when this concept was used
                thronglet.lastConceptUse[concept] = Date.now();
                
                // If the brain visualization is currently showing this Thronglet,
                // we should update it to reflect the concept activation
                if (activeBrainVisualization && activeBrainVisualization.throngletId === thronglet.id) {
                    updateBrainVisualization();
                }
            }
            
            canUseConcept(thronglet, concept) {
                return thronglet.knownConcepts && thronglet.knownConcepts.includes(concept);
            }
            
            getKnownConcepts(thronglet) {
                return thronglet.knownConcepts || [];
            }
            
            getRandomKnownPattern(thronglet) {
                if (!thronglet.knownConcepts || thronglet.knownConcepts.length === 0) {
                    return null;
                }
                
                const randomConcept = thronglet.knownConcepts[Math.floor(Math.random() * thronglet.knownConcepts.length)];
                return this.getPatternForConcept(randomConcept);
            }
            
            // Add method to handle adding morse patterns to a Thronglet's knowledge
            addPatternToThronglet(thronglet, pattern) {
                if (!thronglet) return false;
                
                // Initialize morse patterns array if needed
                if (!thronglet.morsePatterns) {
                    thronglet.morsePatterns = [];
                }
                
                // Check if pattern already exists
                if (!thronglet.morsePatterns.includes(pattern)) {
                    // Add the pattern
                    thronglet.morsePatterns.push(pattern);
                    
                    // Check if this pattern maps to a concept
                    const concept = this.getConceptFromPattern(pattern);
                    if (concept) {
                        // Learn the concept
                        this.learnConcept(thronglet, concept);
                    }
                    
                    // Limit pattern memory to prevent overflow
                    if (thronglet.morsePatterns.length > 20) {
                        thronglet.morsePatterns.shift(); // Remove oldest pattern
                    }
                    
                    return true;
                }
                
                return false;
            }
        }

        // Initialize global instance
        const throngletLanguage = new ThrongletLanguage();
        
        // Add all basic concepts for all Thronglets on initialization
        function initializeAllConceptsForThronglets() {
            console.log("Pre-initializing all concepts for Thronglets");
            
            // The core concepts all Thronglets should understand
            const basicConcepts = ["food", "happy", "sad", "follow"];
            
            for (const thronglet of thronglets) {
                // Pre-integrate all concepts into the neural network
                for (const concept of basicConcepts) {
                    console.log(`Pre-integrating concept '${concept}' into Thronglet #${thronglet.id}'s brain`);
                    
                    // Add to neural networks but with very low initial weights
                    preIntegrateConceptToNeuralNetwork(thronglet, concept);
                    
                    // For visualization purposes, add to known concepts but mark as dormant
                    if (!thronglet.dormantConcepts) {
                        thronglet.dormantConcepts = [];
                    }
                    if (!thronglet.knownConcepts) {
                        thronglet.knownConcepts = [];
                    }
                    if (!thronglet.dormantConcepts.includes(concept) && !thronglet.knownConcepts.includes(concept)) {
                        thronglet.dormantConcepts.push(concept);
                    }
                }
                
                // For creator Thronglet, make all concepts active immediately
                if (thronglet.id === 0) {
                    console.log("Activating all concepts for creator Thronglet");
                    for (const concept of basicConcepts) {
                        activateConceptForThronglet(thronglet, concept);
                    }
                }
            }
        }
        
        // Pre-integrate a concept with very low initial weights
        function preIntegrateConceptToNeuralNetwork(thronglet, concept) {
            if (!agentLearningEnabled || !thronglet || !thronglet.agent) return;
            
            // Add the concept to the agent's state representation with low initial value (dormant)
            if (!thronglet.agent.conceptKnowledge) {
                thronglet.agent.conceptKnowledge = {};
            }
            
            // Set this concept to a very low activation level
            thronglet.agent.conceptKnowledge[concept] = 0.05;
            
            // Modify the getState method to include concepts if not already done
            if (!thronglet.agent._originalGetState && thronglet.agent.getState) {
                // Store the original getState method
                thronglet.agent._originalGetState = thronglet.agent.getState;
                
                // Override with new method that includes concepts
                thronglet.agent.getState = function() {
                    // Get the original state
                    const originalState = this._originalGetState.call(this);
                    
                    // Add concept knowledge to state
                    if (this.conceptKnowledge) {
                        for (const [conceptName, value] of Object.entries(this.conceptKnowledge)) {
                            originalState['concept_' + conceptName] = value;
                        }
                    }
                    
                    return originalState;
                };
            }
            
            // Initialize weights by concept array if not exists
            if (!thronglet.agent.weightsByConcept) {
                thronglet.agent.weightsByConcept = {};
            }
            
            // Create concept-specific weights based on what the concept means, but with very low values
            const conceptWeights = {};
            
            switch(concept) {
                case 'food':
                    // Food concept should increase tendency to move to apples, but initially weak
                    conceptWeights['moveToApple'] = 0.05;
                    break;
                case 'happy':
                    // Happy concept should increase tendency to play, but initially weak
                    conceptWeights['moveToPlay'] = 0.05;
                    conceptWeights['beep'] = 0.05;
                    break;
                case 'sad':
                    // Sad concept might make them more likely to seek help, but initially weak
                    conceptWeights['moveToCreator'] = 0.05;
                    conceptWeights['beep'] = 0.05;
                    break;
                case 'follow':
                    // Follow concept increases likelihood to follow others, but initially weak
                    conceptWeights['followClosest'] = 0.05;
                            break;
                    }
                    
            // Store concept weights in the agent
            thronglet.agent.weightsByConcept[concept] = conceptWeights;
            
            // Update the decideAction method to consider concepts if not already modified
            if (!thronglet.agent._originalDecideAction && thronglet.agent.decideAction) {
                // Store the original decideAction method
                thronglet.agent._originalDecideAction = thronglet.agent.decideAction;
                
                // Override with new method that includes concept influence
                thronglet.agent.decideAction = function() {
                    // First get the action from original method
                    const originalAction = this._originalDecideAction.call(this);
                    
                    // If we're in pure exploration, just return original
                    if (Math.random() < explorationRate) {
                        return originalAction;
                    }
                    
                    // Check if any concepts are active and should influence decision
                    let conceptInfluence = {};
                    
                    for (const [concept, value] of Object.entries(this.conceptKnowledge)) {
                        const weights = this.weightsByConcept[concept];
                        if (weights) {
                            // Only apply concepts with meaningful activation - REDUCED threshold from 0.2 to 0.1
                            if (value > 0.1) {
                                // Apply concept influence
                                for (const [action, weight] of Object.entries(weights)) {
                                    conceptInfluence[action] = (conceptInfluence[action] || 0) + weight * value;
                                }
                            }
                        }
                    }
                    
                    // If there's concept influence, possibly choose from that
                    if (Object.keys(conceptInfluence).length > 0) {
                        const conceptActions = Object.keys(conceptInfluence);
                        const totalInfluence = Object.values(conceptInfluence).reduce((a, b) => a + b, 0);
                        
                        // Chance to follow concept influence increases as weights grow stronger
                        // INCREASED chances of following concept from 0.7 to 0.9
                        if (Math.random() < Math.min(0.9, totalInfluence) && totalInfluence > 0) {
                            // Choose weighted random action based on concept influence
                            const r = Math.random() * totalInfluence;
                            let acc = 0;
                            
                            for (const action of conceptActions) {
                                acc += conceptInfluence[action];
                                if (r <= acc) {
                                    console.log(`Thronglet #${this.throngletId} chose action ${action} based on concept influence (strength: ${totalInfluence.toFixed(2)})`);
                                    return action;
                                }
                            }
                        }
                    }
                    
                    return originalAction;
                };
            }
        }

        // Define a clear function to integrate concept to neural network
        function integrateConceptToNeuralNetwork(thronglet, concept) {
            if (!thronglet || !thronglet.agent) return;
            
            console.log(`Integrating concept '${concept}' into Thronglet #${thronglet.id}'s neural network`);
            
            // First ensure the concept is pre-integrated (setup)
            preIntegrateConceptToNeuralNetwork(thronglet, concept);
            
            // Then immediately activate it to full strength
            if (thronglet.agent.conceptKnowledge) {
                // Set to full activation
                thronglet.agent.conceptKnowledge[concept] = 1.0;
                console.log(`Concept '${concept}' activated to full strength in Thronglet #${thronglet.id}'s neural network`);
            }
            
            // Set strong weights for this concept
            if (thronglet.agent.weightsByConcept && thronglet.agent.weightsByConcept[concept]) {
                const conceptWeights = {};
                
                switch(concept) {
                    case 'food':
                        // Food concept should strongly increase tendency to move to apples
                        conceptWeights['moveToApple'] = 0.8; // Increased from 0.6
                        break;
                    case 'happy':
                        // Happy concept should increase tendency to play and communicate
                        conceptWeights['moveToPlay'] = 0.7; // Increased from 0.5
                        conceptWeights['beep'] = 0.6; // Increased from 0.4
                        break;
                    case 'sad':
                        // Sad concept makes them more likely to seek help and communicate
                        conceptWeights['moveToCreator'] = 0.7; // Increased from 0.5
                        conceptWeights['beep'] = 0.6; // Increased from 0.4
                        break;
                    case 'follow':
                        // Follow concept increases likelihood to follow others
                        conceptWeights['followClosest'] = 0.9; // Increased from 0.7
                        break;
                }
                
                // Update the weights
                thronglet.agent.weightsByConcept[concept] = conceptWeights;
                console.log(`Updated weights for concept '${concept}' in Thronglet #${thronglet.id}'s neural network`);
            }
            
            // Create visual effect to show learning
            createLearningSparkle(thronglet, concept);
        }
        
        // Activate a concept for a Thronglet - move from dormant to active
        function activateConceptForThronglet(thronglet, concept) {
            console.log(`Activating concept '${concept}' for Thronglet #${thronglet.id}`);
            
            // Remove from dormant concepts list
            if (thronglet.dormantConcepts && thronglet.dormantConcepts.includes(concept)) {
                thronglet.dormantConcepts = thronglet.dormantConcepts.filter(c => c !== concept);
            }
            
            // Add to known concepts if not already there
            if (!thronglet.knownConcepts) {
                thronglet.knownConcepts = [];
            }
            if (!thronglet.knownConcepts.includes(concept)) {
                thronglet.knownConcepts.push(concept);
            }
            
            // Create learning sparkle to indicate activation
            createLearningSparkle(thronglet, concept);
            
            // Show the concept in a thought bubble
            const pattern = throngletLanguage.getPatternForConcept(concept);
            showThought(thronglet, pattern);
            
            // Strengthen the neural network connections for this concept
            strengthenConceptConnections(thronglet, concept);
        }
        
        // Strengthen a concept's neural connections when it's actively learned
        function strengthenConceptConnections(thronglet, concept) {
            if (!agentLearningEnabled || !thronglet || !thronglet.agent) return;
            
            console.log(`Strengthening neural connections for concept '${concept}' in Thronglet #${thronglet.id}'s brain`);
            
            // Increase concept activation level
            if (thronglet.agent.conceptKnowledge) {
                thronglet.agent.conceptKnowledge[concept] = 1.0;
            }
            
            // Strengthen the weights for this concept based on what it means
            if (thronglet.agent.weightsByConcept && thronglet.agent.weightsByConcept[concept]) {
                const conceptWeights = {};
                
                switch(concept) {
                    case 'food':
                        // Food concept should strongly increase tendency to move to apples
                        conceptWeights['moveToApple'] = 0.6;
                        break;
                    case 'happy':
                        // Happy concept should increase tendency to play and communicate
                        conceptWeights['moveToPlay'] = 0.5;
                        conceptWeights['beep'] = 0.4;
                        break;
                    case 'sad':
                        // Sad concept makes them more likely to seek help and communicate
                        conceptWeights['moveToCreator'] = 0.5;
                        conceptWeights['beep'] = 0.4;
                        break;
                    case 'follow':
                        // Follow concept increases likelihood to follow others
                        conceptWeights['followClosest'] = 0.7;
                        break;
                }
                
                // Update the weights
                thronglet.agent.weightsByConcept[concept] = conceptWeights;
            }
            
            // Force an update to the brain visualization if active
            if (activeBrainVisualization && activeBrainVisualization.throngletId === thronglet.id) {
                updateBrainVisualization();
            }
            
            // Mark the concept as recently used
            if (!thronglet.lastConceptUse) {
                thronglet.lastConceptUse = {};
            }
            thronglet.lastConceptUse[concept] = Date.now();
        }

        // Function to setup natural concept learning
        function setupNaturalConceptLearning() {
            console.log("Setting up natural concept learning...");
            
            // First pre-integrate all concepts for all Thronglets
            initializeAllConceptsForThronglets();
            
            // Setup a monitoring interval to check Thronglet behavior
            window.throngletMovementMonitor = setInterval(function() {
                for (const thronglet of thronglets) {
                    console.log(`Checking learning for Thronglet #${thronglet.id}: Happiness=${thronglet.happiness}, Hunger=${thronglet.hunger}`);
                    
                    // Debug which conditions are being met
                    const nearApple = thronglet.checkForApple && typeof thronglet.checkForApple === 'function' ? thronglet.checkForApple() : false;
                    const isFollowing = thronglet.followingThrongletId ? true : false;
                    const isHappy = thronglet.happiness > 60;
                    const isSad = thronglet.happiness < 30;
                    
                    console.log(`Thronglet #${thronglet.id} conditions: nearApple=${nearApple}, isFollowing=${isFollowing}, isHappy=${isHappy}, isSad=${isSad}`);
                    
                    // Learn "food" concept when eating apple - not adding the concept, but activating it
                    if (nearApple) {
                        console.log(`Thronglet #${thronglet.id} is near an apple!`);
                        // Higher chance to activate when hungry
                        const learnChance = 0.75;
                        if (Math.random() < learnChance) {
                            console.log(`Attempting to activate food concept for Thronglet #${thronglet.id}`);
                            
                            // Check if the concept is dormant
                            if (thronglet.dormantConcepts && thronglet.dormantConcepts.includes("food")) {
                                console.log(`Activating dormant food concept for Thronglet #${thronglet.id}`);
                                activateConceptForThronglet(thronglet, "food");
                            } 
                            // Strengthen if already active
                            else if (thronglet.knownConcepts && thronglet.knownConcepts.includes("food")) {
                                console.log(`Reinforcing active food concept for Thronglet #${thronglet.id}`);
                                strengthenConceptConnections(thronglet, "food");
                                
                                // Occasionally express the concept
                                if (Math.random() < 0.3) {
                                    const pattern = throngletLanguage.getPatternForConcept("food");
                                    showThought(thronglet, pattern);
                                }
                            }
                        }
                    }
                    
                    // Activate "follow" concept when following another Thronglet
                    if (isFollowing) {
                        console.log(`Thronglet #${thronglet.id} is following another Thronglet`);
                        // High chance to activate
                        if (Math.random() < 0.5) {
                            console.log(`Attempting to activate follow concept for Thronglet #${thronglet.id}`);
                            
                            // Check if concept is dormant
                            if (thronglet.dormantConcepts && thronglet.dormantConcepts.includes("follow")) {
                                console.log(`Activating dormant follow concept for Thronglet #${thronglet.id}`);
                                activateConceptForThronglet(thronglet, "follow");
                            }
                            // Strengthen if already active
                            else if (thronglet.knownConcepts && thronglet.knownConcepts.includes("follow")) {
                                console.log(`Reinforcing active follow concept for Thronglet #${thronglet.id}`);
                                strengthenConceptConnections(thronglet, "follow");
                                
                                // Occasionally express the concept
                                if (Math.random() < 0.3) {
                                    const pattern = throngletLanguage.getPatternForConcept("follow");
                                    showThought(thronglet, pattern);
                                }
                            }
                        }
                    }
                    
                    // Activate "happy" concept when happiness is high
                    if (isHappy) {
                        console.log(`Thronglet #${thronglet.id} is happy (${thronglet.happiness})`);
                        if (Math.random() < 0.5) {
                            console.log(`Attempting to activate happy concept for Thronglet #${thronglet.id}`);
                            
                            // Check if concept is dormant
                            if (thronglet.dormantConcepts && thronglet.dormantConcepts.includes("happy")) {
                                console.log(`Activating dormant happy concept for Thronglet #${thronglet.id}`);
                                activateConceptForThronglet(thronglet, "happy");
                            }
                            // Strengthen if already active
                            else if (thronglet.knownConcepts && thronglet.knownConcepts.includes("happy")) {
                                console.log(`Reinforcing active happy concept for Thronglet #${thronglet.id}`);
                                strengthenConceptConnections(thronglet, "happy");
                                
                                // Occasionally express the concept
                                if (Math.random() < 0.3) {
                                    const pattern = throngletLanguage.getPatternForConcept("happy");
                                    showThought(thronglet, pattern);
                                }
                            }
                        }
                    } 
                    
                    // Activate "sad" concept when happiness is low
                    else if (isSad) {
                        console.log(`Thronglet #${thronglet.id} is sad (${thronglet.happiness})`);
                        if (Math.random() < 0.5) {
                            console.log(`Attempting to activate sad concept for Thronglet #${thronglet.id}`);
                            
                            // Check if concept is dormant
                            if (thronglet.dormantConcepts && thronglet.dormantConcepts.includes("sad")) {
                                console.log(`Activating dormant sad concept for Thronglet #${thronglet.id}`);
                                activateConceptForThronglet(thronglet, "sad");
                            }
                            // Strengthen if already active
                            else if (thronglet.knownConcepts && thronglet.knownConcepts.includes("sad")) {
                                console.log(`Reinforcing active sad concept for Thronglet #${thronglet.id}`);
                                strengthenConceptConnections(thronglet, "sad");
                                
                                // Occasionally express the concept
                                if (Math.random() < 0.3) {
                                    const pattern = throngletLanguage.getPatternForConcept("sad");
                                    showThought(thronglet, pattern);
                                }
                            }
                        }
                    }
                    
                    // Occasionally make the Thronglet express an active concept
                    if (Math.random() < 0.01 && thronglet.knownConcepts && thronglet.knownConcepts.length > 0) {
                        const randomConcept = thronglet.knownConcepts[Math.floor(Math.random() * thronglet.knownConcepts.length)];
                        const pattern = throngletLanguage.getPatternForConcept(randomConcept);
                        if (pattern) {
                            showThought(thronglet, pattern);
                            strengthenConceptConnections(thronglet, randomConcept);
                        }
                    }
                }
            }, 1000);
            
            // Fix checkForApple for Thronglets
            patchThrongletCheckForApple();
        }

        // Function to show a learning sparkle effect above a Thronglet
        function showLearningSparkle(x, y, text) {
            try {
                // Safety check for valid coordinates
                if (typeof x !== 'number' || typeof y !== 'number' || isNaN(x) || isNaN(y)) {
                    console.warn("Invalid coordinates for learning sparkle", x, y);
                    return;
                }
                
                const sparkle = document.createElement('div');
                sparkle.className = 'learning-sparkle';
                sparkle.textContent = text || "Learning!";
                
                // Position the sparkle above the Thronglet
                sparkle.style.left = x + 'px';
                sparkle.style.top = (y - 30) + 'px';
                
                // Random color for different learning events
                const colors = ['#e74c3c', '#f1c40f', '#3498db', '#2ecc71', '#9b59b6'];
                const randomColor = colors[Math.floor(Math.random() * colors.length)];
                sparkle.style.color = randomColor;
                
                // Add to the game scene (with safety check)
                if (gameScene) {
                    gameScene.appendChild(sparkle);
                    
                    // Store reference to use in setTimeout
                    const sparkleRef = sparkle;
                    
                    // Remove after animation completes
                    setTimeout(() => {
                        try {
                            if (sparkleRef && sparkleRef.parentNode) {
                                sparkleRef.parentNode.removeChild(sparkleRef);
                            }
                        } catch (error) {
                            console.warn("Error removing sparkle:", error);
                        }
                    }, 2000);
                }
            } catch (error) {
                console.error("Error in showLearningSparkle:", error);
            }
        }

        // Add agent management functions
        function setupAgentLearningSystem() {
            // Any initial setup for learning system
            
            // Start agent update cycle
            setInterval(() => {
                if (gameActive && agentLearningEnabled) {
                    updateAgentLearning();
                }
            }, 5000); // Update agent metrics every 5 seconds
            
            // Gradually reduce exploration rate as agents learn
            setInterval(() => {
                if (gameActive && agentLearningEnabled && !observationPhase) {
                    explorationRate = Math.max(0.05, explorationRate - 0.01); // Reduce gradually to a minimum of 0.05
                }
            }, 30000); // Every 30 seconds
            
            // Start hidden layers doubling every 3 minutes
            lastHiddenLayersUpdate = Date.now();
            setInterval(updateHiddenLayers, 1000); // Check every second, but only update every 3 minutes
            
            console.log("Agent learning system initialized!");
        }

        // Function to show a learning path between points
        function showLearningPath(startX, startY, endX, endY, color, isMeandering = false) {
            try {
                // Safety check for valid coordinates
                if ([startX, startY, endX, endY].some(coord => 
                    typeof coord !== 'number' || isNaN(coord))) {
                    console.warn("Invalid coordinates for learning path", startX, startY, endX, endY);
                    return;
                }
                
                // Number of dots to show in the path
                const numDots = 10;
                
                for (let i = 0; i < numDots; i++) {
                    // Create dot element
                    const dot = document.createElement('div');
                    dot.className = 'learning-path';
                    
                    // Calculate position
                    let t = i / (numDots - 1); // 0 to 1
                    
                    // For meandering path (when learning), add some randomness
                    let x, y;
                    if (isMeandering) {
                        const randomX = (Math.random() - 0.5) * 30;
                        const randomY = (Math.random() - 0.5) * 30;
                        x = startX + t * (endX - startX) + randomX;
                        y = startY + t * (endY - startY) + randomY;
                    } else {
                        x = startX + t * (endX - startX);
                        y = startY + t * (endY - startY);
                    }
                    
                    // Set dot size and position
                    const size = 8 - (i * 3 / numDots); // Smaller dots as they get further from start
                    dot.style.width = `${size}px`;
                    dot.style.height = `${size}px`;
                    dot.style.left = `${x - size/2}px`;
                    dot.style.top = `${y - size/2}px`;
                    dot.style.backgroundColor = color || '#ffffff';
                    
                    // Add to the game scene (with safety check)
                    if (gameScene) {
                        gameScene.appendChild(dot);
                        
                        // Store reference to use in setTimeout
                        const dotRef = dot;
                        
                        // Add a slight delay for each dot to create a flowing effect
                        setTimeout(() => {
                            try {
                                if (dotRef && dotRef.parentNode) {
                                    dotRef.parentNode.removeChild(dotRef);
                                }
                            } catch (error) {
                                console.warn("Error removing path dot:", error);
                            }
                        }, 1500 + i * 100);
                    }
                }
            } catch (error) {
                console.error("Error in showLearningPath:", error);
            }
        }
    </script>
</body>
</html>